<html>

<head>
<meta http-equiv=Content-Type content="text/html; charset=gb2312">
<meta name=Generator content="Microsoft Word 15 (filtered)">
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:宋体;
	panose-1:2 1 6 0 3 1 1 1 1 1;}
@font-face
	{font-family:"Cambria Math";
	panose-1:2 4 5 3 5 4 6 3 2 4;}
@font-face
	{font-family:等线;
	panose-1:2 1 6 0 3 1 1 1 1 1;}
@font-face
	{font-family:"\@宋体";
	panose-1:2 1 6 0 3 1 1 1 1 1;}
@font-face
	{font-family:"\@等线";
	panose-1:2 1 6 0 3 1 1 1 1 1;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{margin:0cm;
	text-align:justify;
	text-justify:inter-ideograph;
	font-size:10.5pt;
	font-family:等线;}
h1
	{mso-style-link:"标题 1 字符";
	margin-top:24.0pt;
	margin-right:0cm;
	margin-bottom:4.0pt;
	margin-left:0cm;
	text-align:justify;
	text-justify:inter-ideograph;
	page-break-after:avoid;
	font-size:24.0pt;
	font-family:"等线 Light";
	color:#0F4761;
	font-weight:normal;}
h2
	{mso-style-link:"标题 2 字符";
	margin-top:8.0pt;
	margin-right:0cm;
	margin-bottom:4.0pt;
	margin-left:0cm;
	text-align:justify;
	text-justify:inter-ideograph;
	page-break-after:avoid;
	font-size:20.0pt;
	font-family:"等线 Light";
	color:#0F4761;
	font-weight:normal;}
h3
	{mso-style-link:"标题 3 字符";
	margin-top:8.0pt;
	margin-right:0cm;
	margin-bottom:4.0pt;
	margin-left:0cm;
	text-align:justify;
	text-justify:inter-ideograph;
	page-break-after:avoid;
	font-size:16.0pt;
	font-family:"等线 Light";
	color:#0F4761;
	font-weight:normal;}
h4
	{mso-style-link:"标题 4 字符";
	margin-top:4.0pt;
	margin-right:0cm;
	margin-bottom:2.0pt;
	margin-left:0cm;
	text-align:justify;
	text-justify:inter-ideograph;
	page-break-after:avoid;
	font-size:14.0pt;
	font-family:等线;
	color:#0F4761;
	font-weight:normal;}
h5
	{mso-style-link:"标题 5 字符";
	margin-top:4.0pt;
	margin-right:0cm;
	margin-bottom:2.0pt;
	margin-left:0cm;
	text-align:justify;
	text-justify:inter-ideograph;
	page-break-after:avoid;
	font-size:12.0pt;
	font-family:等线;
	color:#0F4761;
	font-weight:normal;}
h6
	{mso-style-link:"标题 6 字符";
	margin-top:2.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	text-align:justify;
	text-justify:inter-ideograph;
	page-break-after:avoid;
	font-size:10.5pt;
	font-family:等线;
	color:#0F4761;
	font-weight:bold;}
p.MsoHeading7, li.MsoHeading7, div.MsoHeading7
	{mso-style-link:"标题 7 字符";
	margin-top:2.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	text-align:justify;
	text-justify:inter-ideograph;
	page-break-after:avoid;
	font-size:10.5pt;
	font-family:等线;
	color:#595959;
	font-weight:bold;}
p.MsoHeading8, li.MsoHeading8, div.MsoHeading8
	{mso-style-link:"标题 8 字符";
	margin:0cm;
	text-align:justify;
	text-justify:inter-ideograph;
	page-break-after:avoid;
	font-size:10.5pt;
	font-family:等线;
	color:#595959;}
p.MsoHeading9, li.MsoHeading9, div.MsoHeading9
	{mso-style-link:"标题 9 字符";
	margin:0cm;
	text-align:justify;
	text-justify:inter-ideograph;
	page-break-after:avoid;
	font-size:10.5pt;
	font-family:等线;
	color:#595959;}
p.MsoHeader, li.MsoHeader, div.MsoHeader
	{mso-style-link:"页眉 字符";
	margin:0cm;
	text-align:center;
	layout-grid-mode:char;
	font-size:9.0pt;
	font-family:等线;}
p.MsoFooter, li.MsoFooter, div.MsoFooter
	{mso-style-link:"页脚 字符";
	margin:0cm;
	text-align:left;
	layout-grid-mode:char;
	font-size:9.0pt;
	font-family:等线;}
p.MsoTitle, li.MsoTitle, div.MsoTitle
	{mso-style-link:"标题 字符";
	margin-top:0cm;
	margin-right:0cm;
	margin-bottom:4.0pt;
	margin-left:0cm;
	text-align:center;
	font-size:28.0pt;
	font-family:"等线 Light";
	letter-spacing:-.5pt;}
p.MsoTitleCxSpFirst, li.MsoTitleCxSpFirst, div.MsoTitleCxSpFirst
	{mso-style-link:"标题 字符";
	margin:0cm;
	margin-bottom:.0001pt;
	text-align:center;
	font-size:28.0pt;
	font-family:"等线 Light";
	letter-spacing:-.5pt;}
p.MsoTitleCxSpMiddle, li.MsoTitleCxSpMiddle, div.MsoTitleCxSpMiddle
	{mso-style-link:"标题 字符";
	margin:0cm;
	margin-bottom:.0001pt;
	text-align:center;
	font-size:28.0pt;
	font-family:"等线 Light";
	letter-spacing:-.5pt;}
p.MsoTitleCxSpLast, li.MsoTitleCxSpLast, div.MsoTitleCxSpLast
	{mso-style-link:"标题 字符";
	margin-top:0cm;
	margin-right:0cm;
	margin-bottom:4.0pt;
	margin-left:0cm;
	text-align:center;
	font-size:28.0pt;
	font-family:"等线 Light";
	letter-spacing:-.5pt;}
p.MsoSubtitle, li.MsoSubtitle, div.MsoSubtitle
	{mso-style-link:"副标题 字符";
	margin-top:0cm;
	margin-right:0cm;
	margin-bottom:8.0pt;
	margin-left:0cm;
	text-align:center;
	font-size:14.0pt;
	font-family:"等线 Light";
	color:#595959;
	letter-spacing:.75pt;}
a:link, span.MsoHyperlink
	{color:#467886;
	text-decoration:underline;}
a:visited, span.MsoHyperlinkFollowed
	{color:#96607D;
	text-decoration:underline;}
p
	{margin:0cm;
	text-align:justify;
	text-justify:inter-ideograph;
	font-size:12.0pt;
	font-family:"Times New Roman",serif;}
p.MsoListParagraph, li.MsoListParagraph, div.MsoListParagraph
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:36.0pt;
	text-align:justify;
	text-justify:inter-ideograph;
	font-size:10.5pt;
	font-family:等线;}
p.MsoListParagraphCxSpFirst, li.MsoListParagraphCxSpFirst, div.MsoListParagraphCxSpFirst
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:36.0pt;
	text-align:justify;
	text-justify:inter-ideograph;
	font-size:10.5pt;
	font-family:等线;}
p.MsoListParagraphCxSpMiddle, li.MsoListParagraphCxSpMiddle, div.MsoListParagraphCxSpMiddle
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:36.0pt;
	text-align:justify;
	text-justify:inter-ideograph;
	font-size:10.5pt;
	font-family:等线;}
p.MsoListParagraphCxSpLast, li.MsoListParagraphCxSpLast, div.MsoListParagraphCxSpLast
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:36.0pt;
	text-align:justify;
	text-justify:inter-ideograph;
	font-size:10.5pt;
	font-family:等线;}
p.MsoQuote, li.MsoQuote, div.MsoQuote
	{mso-style-link:"引用 字符";
	margin-top:8.0pt;
	margin-right:0cm;
	margin-bottom:8.0pt;
	margin-left:0cm;
	text-align:center;
	font-size:10.5pt;
	font-family:等线;
	color:#404040;
	font-style:italic;}
p.MsoIntenseQuote, li.MsoIntenseQuote, div.MsoIntenseQuote
	{mso-style-link:"明显引用 字符";
	margin-top:18.0pt;
	margin-right:43.2pt;
	margin-bottom:18.0pt;
	margin-left:43.2pt;
	text-align:center;
	border:none;
	padding:0cm;
	font-size:10.5pt;
	font-family:等线;
	color:#0F4761;
	font-style:italic;}
span.MsoIntenseEmphasis
	{color:#0F4761;
	font-style:italic;}
span.MsoIntenseReference
	{font-variant:small-caps;
	color:#0F4761;
	letter-spacing:.25pt;
	font-weight:bold;}
span.1
	{mso-style-name:"标题 1 字符";
	mso-style-link:"标题 1";
	font-family:"等线 Light";
	color:#0F4761;}
span.2
	{mso-style-name:"标题 2 字符";
	mso-style-link:"标题 2";
	font-family:"等线 Light";
	color:#0F4761;}
span.3
	{mso-style-name:"标题 3 字符";
	mso-style-link:"标题 3";
	font-family:"等线 Light";
	color:#0F4761;}
span.4
	{mso-style-name:"标题 4 字符";
	mso-style-link:"标题 4";
	font-family:"Times New Roman",serif;
	color:#0F4761;}
span.5
	{mso-style-name:"标题 5 字符";
	mso-style-link:"标题 5";
	font-family:"Times New Roman",serif;
	color:#0F4761;}
span.6
	{mso-style-name:"标题 6 字符";
	mso-style-link:"标题 6";
	font-family:"Times New Roman",serif;
	color:#0F4761;
	font-weight:bold;}
span.7
	{mso-style-name:"标题 7 字符";
	mso-style-link:"标题 7";
	font-family:"Times New Roman",serif;
	color:#595959;
	font-weight:bold;}
span.8
	{mso-style-name:"标题 8 字符";
	mso-style-link:"标题 8";
	font-family:"Times New Roman",serif;
	color:#595959;}
span.9
	{mso-style-name:"标题 9 字符";
	mso-style-link:"标题 9";
	font-family:"等线 Light";
	color:#595959;}
span.a
	{mso-style-name:"标题 字符";
	mso-style-link:标题;
	font-family:"等线 Light";
	letter-spacing:-.5pt;}
span.a0
	{mso-style-name:"副标题 字符";
	mso-style-link:副标题;
	font-family:"等线 Light";
	color:#595959;
	letter-spacing:.75pt;}
span.a1
	{mso-style-name:"引用 字符";
	mso-style-link:引用;
	color:#404040;
	font-style:italic;}
span.a2
	{mso-style-name:"明显引用 字符";
	mso-style-link:明显引用;
	color:#0F4761;
	font-style:italic;}
span.tw-text-gray-900
	{mso-style-name:tw-text-gray-900;}
span.tw-text-lg
	{mso-style-name:tw-text-lg;}
span.a3
	{mso-style-name:"页眉 字符";
	mso-style-link:页眉;}
span.a4
	{mso-style-name:"页脚 字符";
	mso-style-link:页脚;}
.MsoChpDefault
	{font-family:等线;}
.MsoPapDefault
	{text-align:justify;
	text-justify:inter-ideograph;}
 /* Page Definitions */
 @page WordSection1
	{size:595.3pt 841.9pt;
	margin:36.0pt 36.0pt 36.0pt 36.0pt;
	layout-grid:15.6pt;}
div.WordSection1
	{page:WordSection1;}
 /* List Definitions */
 ol
	{margin-bottom:0cm;}
ul
	{margin-bottom:0cm;}
-->
</style>

</head>

<body lang=ZH-CN link="#467886" vlink="#96607D" style='word-wrap:break-word;
text-justify-trim:punctuation'>

<div class=WordSection1 style='layout-grid:15.6pt'>

<div align=center>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='border-collapse:collapse;border:none'>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=left style='text-align:left;text-indent:24.1pt;
  line-height:115%'><b><span lang=EN-US style='font-size:12.0pt;line-height:
  115%;font-family:"Times New Roman",serif'>vue</span></b><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>的父子组件通信</span></b></p>
  <p class=MsoNormal align=left style='text-align:left;text-indent:24.0pt;
  line-height:115%'><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>父组件通过</span><span lang=EN-US style='font-size:12.0pt;line-height:115%;
  font-family:"Times New Roman",serif'>props</span><span style='font-size:12.0pt;
  line-height:115%;font-family:宋体'>向子组件传递数据，子组件通过</span><span lang=EN-US
  style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>props</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>接收数据。而子组件向父组件通信，则可以通过</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>$emit</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>方法触发一个自定义事件，父组件通过监听这个事件来接收数据。</span></p>
  <p class=MsoNormal align=left style='text-align:left;text-indent:24.0pt;
  line-height:115%'><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>父组件可以通过</span><span lang=EN-US style='font-size:12.0pt;line-height:115%;
  font-family:"Times New Roman",serif'>ref</span><span style='font-size:12.0pt;
  line-height:115%;font-family:宋体'>引用子组件实例，直接调用子组件的属性和方法</span></p>
  <p class=MsoNormal align=left style='text-align:left;text-indent:24.0pt;
  line-height:115%'><span lang=EN-US style='font-size:12.0pt;line-height:115%;
  font-family:"Times New Roman",serif'>Vue</span><span style='font-size:12.0pt;
  line-height:115%;font-family:宋体'>提供了一个</span><span lang=EN-US
  style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>v-model</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>指令，它是一个语法糖，可以用来在父子组件之间创建双向数据绑定。</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>v-model&nbsp;</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>绑定父组件的</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;value&nbsp;</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>数据属性。</span></p>
  <p class=MsoNormal align=left style='text-align:left;text-indent:24.0pt;
  line-height:115%'><span lang=EN-US style='font-size:12.0pt;line-height:115%;
  font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.1pt;line-height:115%'><b><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>tcp</span></b><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>协议中，三次握手四次挥手是怎样的</span></b></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>三次握手是为了确保双方能够正常通信，而四次挥手则是为了确保双方都能够正常关闭连接。</span><span
  style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>
  </span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>在</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>TCP</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>协议中，三次握手的具体流程如下：首先客户端向服务器端发送一个</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>SYN</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>包，表示请求建立连接；服务器收到后回复一个</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>SYN+ACK</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>包，表示确认请求并同意建立连接；最后客户端再发送一个</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>ACK</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>包，表示连接建立成功。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>四次挥手的流程为：首先一方发送一个</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>FIN</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>包，表示要关闭连接；接收到</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>FIN</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>的一方回复一个</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>ACK</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>包，表示收到关闭请求；然后这一方会发送一个</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>FIN</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>包，表示自己也要关闭连接；最后对方再回复一个</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>ACK</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>包，表示同意关闭连接。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.1pt;line-height:115%'><b><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Redis</span></b><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>除了缓存，还能做什么</span></b></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>除了作为缓存，</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Redis</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>还有很多其他的用途。比如可以利用</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Redis</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>的发布</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>/</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>订阅功能实现消息队列的功能，可以将数据持久化到磁盘上，还可以用</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Redis</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>的</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>INCR</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>命令实现计数器的功能，同时</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Redis</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>还提供了</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>SETNX</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>命令来实现分布式锁。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.1pt;line-height:115%'><b><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>redis</span></b><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>缓存更新方案</span></b></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Redis
  </span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>是一个高性能的键值数据库，常用于缓存、会话存储、消息队列等场景。</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Redis</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>缓存更新方案可以采用主动更新和被动更新两种方式。</span><span
  style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>
  </span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>解答思路：主动更新是指在数据更新的同时，主动将缓存中对应的数据进行更新或失效处理；被动更新是指等到下次访问缓存数据时，再去数据库查询最新数据并更新缓存。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.1pt;line-height:115%'><b><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>redis</span></b><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>的跳表是怎么实现的？</span></b></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>跳表（</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Skip
  List</span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>）是一种随机化数据结构，通过在有序链表的基础上增加多层索引来加快查询速度。在</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Redis</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>中，跳表被用来实现有序集合（</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Sorted
  Set</span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>）数据结构。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>跳表的实现主要包括节点结构的设计、插入、删除、查找等操作。每个节点包括键、值、层数等信息，插入操作需要按照一定概率随机选择节点的层数，删除操作需要更新节点的前后指针，查找操作需要根据索引层逐层缩小范围直至到达最底层。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.1pt;line-height:115%'><b><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>http</span></b><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>的几种请求有什么区别</span></b></p>
  <p class=MsoNormal style='margin-left:39.25pt;text-indent:24.1pt;line-height:
  115%'><span lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:
  "Times New Roman",serif'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  </span></span><b><span lang=EN-US style='font-size:12.0pt;line-height:115%;
  font-family:"Times New Roman",serif'>GET</span></b><span style='font-size:
  12.0pt;line-height:115%;font-family:宋体'>：</span></p>
  <p class=MsoNormal style='margin-left:75.25pt;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'> </span></span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>用于请求指定的资源。</span></p>
  <p class=MsoNormal style='margin-left:75.25pt;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'> </span></span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>数据在</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>URL</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>中发送，</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>URL</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>的长度有限制。</span></p>
  <p class=MsoNormal style='margin-left:75.25pt;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'> </span></span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>安全性相对较高，因为数据在</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>URL</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>中是可见的。</span></p>
  <p class=MsoNormal style='margin-left:75.25pt;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'> </span></span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>不应产生副作用，即不会改变资源的状态。可缓存。</span></p>
  <p class=MsoNormal style='margin-left:39.25pt;text-indent:24.1pt;line-height:
  115%'><span lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:
  "Times New Roman",serif'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  </span></span><b><span lang=EN-US style='font-size:12.0pt;line-height:115%;
  font-family:"Times New Roman",serif'>POST</span></b><span style='font-size:
  12.0pt;line-height:115%;font-family:宋体'>：</span></p>
  <p class=MsoNormal style='margin-left:75.25pt;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'> </span></span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>用于提交数据到服务器，例如提交表单或上传文件。</span></p>
  <p class=MsoNormal style='margin-left:75.25pt;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'> </span></span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>数据在请求体（</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>body</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>）中发送，理论上没有大小限制。</span></p>
  <p class=MsoNormal style='margin-left:75.25pt;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'> </span></span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>安全性相对较低，因为数据不在</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>URL</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>中显示，但可以通过加密（如</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>HTTPS</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>）提高安全性。</span></p>
  <p class=MsoNormal style='margin-left:75.25pt;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'> </span></span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>通常会产生副作用，如创建或更新资源。不可缓存。</span></p>
  <p class=MsoNormal style='margin-left:39.25pt;text-indent:24.1pt;line-height:
  115%'><span lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:
  "Times New Roman",serif'>3.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  </span></span><b><span lang=EN-US style='font-size:12.0pt;line-height:115%;
  font-family:"Times New Roman",serif'>PUT</span></b><span style='font-size:
  12.0pt;line-height:115%;font-family:宋体'>：</span></p>
  <p class=MsoNormal style='margin-left:75.25pt;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'> </span></span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>用于向服务器发送数据，通常用于更新资源。</span></p>
  <p class=MsoNormal style='margin-left:75.25pt;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'> </span></span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>数据在请求体中发送。</span></p>
  <p class=MsoNormal style='margin-left:75.25pt;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'> </span></span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>通常用于更新资源，如果资源不存在，可能会创建新资源。</span></p>
  <p class=MsoNormal style='margin-left:75.25pt;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'> </span></span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>产生副作用。可缓存，但需要谨慎处理，因为可能会更新资源。</span></p>
  <p class=MsoNormal style='margin-left:39.25pt;text-indent:24.1pt;line-height:
  115%'><span lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:
  "Times New Roman",serif'>4.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  </span></span><b><span lang=EN-US style='font-size:12.0pt;line-height:115%;
  font-family:"Times New Roman",serif'>DELETE</span></b><span style='font-size:
  12.0pt;line-height:115%;font-family:宋体'>：</span></p>
  <p class=MsoNormal style='margin-left:75.25pt;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'> </span></span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>用于请求删除指定的资源。</span></p>
  <p class=MsoNormal style='margin-left:75.25pt;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'> </span></span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>不需要发送数据体，但可以发送来指定删除的条件。</span></p>
  <p class=MsoNormal style='margin-left:75.25pt;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'> </span></span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>产生副作用，即删除资源。可缓存，但需要确保缓存与实际资源状态一致。</span></p>
  <p class=MsoNormal style='margin-left:39.25pt;text-indent:24.1pt;line-height:
  115%'><span lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:
  "Times New Roman",serif'>5.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  </span></span><b><span lang=EN-US style='font-size:12.0pt;line-height:115%;
  font-family:"Times New Roman",serif'>PATCH</span></b><span style='font-size:
  12.0pt;line-height:115%;font-family:宋体'>：</span></p>
  <p class=MsoNormal style='margin-left:75.25pt;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'> </span></span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>用于对资源进行部分更新。</span></p>
  <p class=MsoNormal style='margin-left:75.25pt;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'> </span></span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>数据在请求体中发送。</span></p>
  <p class=MsoNormal style='margin-left:75.25pt;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'> </span></span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>产生副作用，即更新资源。可缓存，但需要谨慎处理。</span></p>
  <p class=MsoNormal style='line-height:115%'><span lang=EN-US
  style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.1pt;line-height:115%'><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>全局唯一订单</span></b><b><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>id</span></b><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>实现，</span></b><b><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>redis</span></b><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>起了什么作用</span></b></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>在实现全局唯一订单</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>ID</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>时，</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Redis</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>可以起到生成分布式唯一</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>ID</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>和分布式锁的作用。</span><span
  style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>
  </span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>解答思路：首先，可以使用</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Redis</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>的自增特性来生成全局唯一订单</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>ID</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>。通过将订单</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>ID</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>存储在</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Redis</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>的自增计数器中，并设置适当的前缀和格式，可以确保生成的订单</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>ID</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>在整个系统中是唯一的。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>分布式锁是一种在分布式系统中协调多个进程或线程对共享资源访问的机制。可以利用</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Redis</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>的分布式锁功能来保证在生成订单</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>ID</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>时的并发安全性，避免重复生成或者重复使用订单</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>ID</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.1pt;line-height:115%'><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>描述一下</span></b><b><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>http</span></b><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>协议中，</span></b><b><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>http&nbsp;</span></b><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>基于哪些协议实现</span></b></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>解答思路：</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>HTTP</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>是基于</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>TCP/IP</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>协议栈的应用层协议，通过</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>TCP</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>协议提供可靠的数据传输服务，确保数据的完整性和顺序性。</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>HTTP</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>使用</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>TCP</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>的连接建立、数据传输和连接释放的机制，来实现客户端和服务器之间的通信。</span><span
  style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>
  </span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>TCP/IP</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>协议是互联网的基础协议，由</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>TCP</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>传输控制协议和</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>IP</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>网际协议组成。</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>TCP</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>提供面向连接的可靠数据传输，保证数据的完整性和顺序性；而</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>IP</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>则负责数据包的路由和转发。</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>HTTP</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>作为应用层协议，利用</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>TCP/IP</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>协议栈提供的服务来实现客户端和服务器之间的通信。在</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>HTTP</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>请求和响应的过程中，</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>TCP</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>负责建立连接、传输数据、保证数据的可靠性，而</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>IP</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>则负责数据包的路由和转发。</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>HTTP</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>基于</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>TCP/IP</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>协议实现的特点使得它能够在全球范围内实现网络通信，并且保证数据传输的可靠性和稳定性。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.1pt;line-height:115%'><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>接口和抽象类是面向对象编程中常用的两种机制，它们都可以用来实现多态性，但在具体的使用场景和特点上有一些不同。</span></b></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>接口是一种抽象的数据类型，它定义了一组方法的签名，但没有具体的实现。一个类可以实现一个或多个接口，实现接口的类必须实现接口定义的所有方法。接口中的方法默认是</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>public</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>的，并且不能包含成员变量。接口可以用来实现多继承，可以解决</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Java</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>单继承的问题。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>抽象类是一种包含抽象方法的类，它可以包含具体的方法和成员变量。抽象类不能被实例化，只能被继承。子类必须实现抽象类中的所有抽象方法，否则子类也必须声明为抽象类。抽象类可以用来约束子类的行为，提供一些通用的方法供子类使用。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>相同点：</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>1.
  </span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>都可以用来实现多态性，让不同的对象可以以相同的方式进行操作。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>2.
  </span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>都可以被子类继承或实现，实现代码的复用和扩展。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>不同点：</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>1.
  </span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>接口中的方法默认是</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>public</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>的，抽象类中的抽象方法可以有不同的访问修饰符。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>2.
  </span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>一个类可以实现多个接口，但只能继承一个抽象类。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>3.
  </span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>接口不能包含成员变量，抽象类可以包含成员变量和具体方法。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>4.
  </span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>接口用来定义规范，抽象类用来定义一些通用的方法和属性。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.1pt;line-height:115%'><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>快速排序的平均时间复杂度为</span></b><b><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>O(nlogn)</span></b><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>，但是快速排序是不稳定的排序算法。</span></b></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>排序算法的稳定性是指能保持相等元素原有顺序的排序算法。快速排序是不稳定的，原因在于分区操作可能会改变相等元素的相对顺序。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>最坏情况下的复杂度是</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>O(n^2)</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>，当基准选择不当（例如，总是选择最小或最大的元素作为基准）时会发生。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.1pt;line-height:115%'><b><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Mysql</span></b><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>的锁</span></b></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>正确答案：</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>MySQL</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>中的锁可以分为共享锁和排他锁，用于控制对数据的访问权限。共享锁（</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Shared
  Lock</span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>）允许多个事务同时读取同一行数据，但不允许其他事务对该数据进行修改，适用于读取操作。排他锁（</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Exclusive
  Lock</span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>）则只允许一个事务对数据进行修改，其他事务不能同时读取或修改该数据，适用于写入操作。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>分治和动态规划的区别</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>分治和动态规划都是常见的算法设计思想，它们在解决问题时有一些相似之处，但也有一些明显的区别。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>分治：分治算法将一个大问题分解成若干个相同或相似的子问题，递归地解决这些子问题，然后合并子问题的解来得到原问题的解。典型的分治算法有归并排序和快速排序。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>动态规划：动态规划则是将原问题分解成若干个重叠子问题，通过保存子问题的解来避免重复计算，通常使用一个表格来保存子问题的解。典型的动态规划问题有背包问题和最长公共子序列问题。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>分布式场景下如何保证线程安全？</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>正确答案：在分布式场景下，保证线程安全的主要方式是使用分布式锁。分布式锁可以通过一致性哈希算法、</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>ZooKeeper</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>、</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Redis</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>等实现。通过获取分布式锁，可以确保在多个节点上的不同线程之间互斥地访问共享资源，从而保证线程安全。</span><span
  style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>
  </span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.1pt;line-height:115%'><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>常用的算法思想包括二分法、贪心算法、动态规划和分治算法。</span></b><span
  style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>
  </span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>1.
  </span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>二分法：通过不断将搜索范围缩小一半来快速查找目标值的算法思想。通常用于有序数组或有序列表的查找操作。</span><span
  style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>
  </span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>2.
  </span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>贪心算法：每一步都选择当前状态下最优的解，希望最终能够得到全局最优解的算法思想。贪心算法通常用于求解最优化问题。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;3.
  </span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>动态规划：将问题分解成子问题，通过保存子问题的解避免重复计算，从而降低时间复杂度的算法思想。动态规划常用于求解最优化问题。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;4.
  </span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>分治算法：将大问题分解成小问题，分别解决再合并结果的算法思想。适用于可以将问题分解成独立子问题的情况。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>在计算机科学中，直接排序（也称为插入排序）的时间复杂度为</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>O(n^2)</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>。在最坏情况下，需要比较</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>n*(n-1)/2</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>次，而在最佳情况下，需要比较</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>n-1</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>次。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>直接排序是一种简单直观的排序算法，通过将未排序的元素一个个插入到已排序的部分中，来达到排序的目的。其基本思路是从第二个元素开始，逐个将元素插入到已排序序列的合适位置。时间复杂度分析：在最坏情况下，直接排序的时间复杂度为</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>O(n^2)</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>，因为每个元素都要与前面的元素进行比较和移动。在最佳情况下，</span><span
  style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>
  </span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>如果待排序的数组已经是有序的，直接排序的时间复杂度为</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>O(n)</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>，因为只需要比较</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>n-1</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>次即可完成排序。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>直接排序虽然简单，但是在处理大规模数据时效率较低，因为其时间复杂度为</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>O(n^2)</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>，在实际应用中一般不推荐使用。排序算法中常用的高效算法有快速排序、归并排序、堆排序等，它们的时间复杂度通常为</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>O(nlogn)</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>，在处理大规模数据时更加高效。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>java</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>面向对象的特性</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>正确答案：</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Java</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>面向对象的特性包括封装、继承和多态。</span><span
  style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>
  </span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>解答思路：首先，封装是指将数据和方法封装在类内部，通过访问权限控制符（</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>public</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>、</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>private</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>、</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>protected</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>）来限制对类的访问，提高安全性和代码复用性。继承是指一个类可以继承另一个类的属性和方法，实现代码的重用和扩展。多态是指同一个方法调用可以根据对象的不同表现出不同的行为，提高代码的灵活性和可扩展性。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Spring</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>三件套框架？</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Spring
  </span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>三件套指的是</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>
  Spring </span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>框架的三个核心模块，分别是</span><span lang=EN-US style='font-size:12.0pt;line-height:
  115%;font-family:"Times New Roman",serif'> Spring Core</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>、</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Spring
  AOP </span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>和</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>
  Spring MVC</span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>。</span><span style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>
  </span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Spring
  Core</span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>：提供了</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>
  IoC</span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>容器，用于对象之间的解耦，通过容器自动将对象之间的依赖注入。同时，</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Spring
  Core </span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>还提供了对</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>
  AspectJ </span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>的集成，以及对基于注解的</span><span lang=EN-US style='font-size:12.0pt;line-height:
  115%;font-family:"Times New Roman",serif'> Spring Bean </span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>的支持。</span><span
  style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>
  </span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Spring
  AOP</span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>：提供了基于</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>
  AOP</span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>的编程方式，能够在不修改源代码的情况下，通过代理机制对对象进行增强，比如添加事务、日志、安全检查等功能。</span><span
  style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>
  </span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Spring
  MVC</span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>：是</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>
  Spring </span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>框架的</span><span lang=EN-US style='font-size:12.0pt;line-height:115%;
  font-family:"Times New Roman",serif'> Web </span><span style='font-size:12.0pt;
  line-height:115%;font-family:宋体'>模块，提供了</span><span lang=EN-US
  style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>
  MVC</span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>模式的支持，用于处理</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>
  Web </span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>请求和响应。</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Spring
  MVC </span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>通过</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>
  DispatcherServlet</span><span style='font-size:12.0pt;line-height:115%;
  font-family:宋体'>、</span><span lang=EN-US style='font-size:12.0pt;line-height:
  115%;font-family:"Times New Roman",serif'>HandlerMapping</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>、</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Controller
  </span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>和</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>
  ViewResolver </span><span style='font-size:12.0pt;line-height:115%;
  font-family:宋体'>等组件构成了完整的</span><span lang=EN-US style='font-size:12.0pt;
  line-height:115%;font-family:"Times New Roman",serif'> MVC </span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>模式的实现。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>MVC</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>（模型</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>-</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>视图</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>-</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>控制器）是一种软件设计模式，通过将应用程序分为三个互不依赖的组件</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>――</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>模型（管理数据和业务逻辑）、视图（展示数据给用户）和控制器（处理用户输入和更新模型和视图）</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>――</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>来实现代码的分离和重用，从而提高应用程序的灵活性和可维护性。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.1pt;line-height:115%'><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>说一说</span></b><b><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>HTML</span></b><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>语义化？</span></b></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>HTML</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>语义化是指在使用</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>HTML</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>标签构建网页时，选择合适的标签来表示内容的结构和意义，而不是仅仅关注页面的外观。使用正确的标签来定义内容的类型。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>使用</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&lt;header&gt;</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>标签表示页面的头部，</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&lt;nav&gt;</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>标签表示导航栏，</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&lt;article&gt;</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>标签表示独立的文章内容，</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&lt;section&gt;</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>标签表示页面中的一个区段，</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&lt;footer&gt;</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>标签表示页面的底部。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>使用</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&lt;h1&gt;</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>到</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&lt;h6&gt;</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>标签来表示标题和子标题，这些标签按照重要性递减，有助于搜索引擎理解内容的层次结构。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>使用</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&lt;p&gt;</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>标签来表示段落，</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&lt;ul&gt;</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>、</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&lt;ol&gt;</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>和</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&lt;li&gt;</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>标签来表示无序列表和有序列表。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>使用</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&lt;a&gt;</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>标签来定义超链接，</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&lt;img&gt;</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>标签来嵌入图像，并使用</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>alt</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>属性为图像提供替代文本，以便在图像无法显示时向用户传达信息。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>使用</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&lt;strong&gt;</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>和</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&lt;em&gt;</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>标签来强调文本，而不是仅仅为了加粗或斜体样式。</span></p>
  <p class=MsoNormal style='line-height:115%'><span lang=EN-US
  style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.1pt;line-height:115%'><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>说一说样式优先级的规则是什么？</span></b></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>样式优先级的规则是基于特异性（</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>specificity</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>）来决定的，特异性越高，样式越优先被应用。具体规则是：行内样式</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>
  &gt; ID</span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>选择器</span><span lang=EN-US style='font-size:12.0pt;line-height:115%;
  font-family:"Times New Roman",serif'> &gt; </span><span style='font-size:
  12.0pt;line-height:115%;font-family:宋体'>类选择器</span><span lang=EN-US
  style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>/</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>属性选择器</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>/</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>伪类</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>
  &gt; </span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>元素选择器</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>/</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>伪元素，同时，具体性相同的情况下，后面的样式会覆盖前面的样式。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.1pt;line-height:115%'><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>说一说</span></b><b><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>CSS</span></b><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>尺寸设置的单位</span></b></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>CSS</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>尺寸设置的单位有多种，包括像素（</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>px</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>）、百分比（</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>%</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>）、</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>em</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>、</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>rem</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>、</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>vw</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>（视口宽度）、</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>vh</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>（视口高度）等，不同的单位适用于不同的设计场景，例如，</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>rem</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>和</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>em</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>更适合响应式设计，而像素则适用于精确的尺寸控制。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.1pt;line-height:115%'><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>说几个未知宽高元素水平垂直居中方法</span></b></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>对于未知宽高的元素实现水平垂直居中，可以使用</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Flexbox</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>布局，通过设置父容器的</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>justify-content</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>和</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>align-items</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>为</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>center</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>来实现。另一种方法是使用</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>CSS
  Grid</span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>，通过</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>place-items</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>属性设置为</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>center</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>也可以达到同样的效果。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.1pt;line-height:115%'><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>说一说</span></b><b><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>JS</span></b><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>数据类型有哪些</span></b><b><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>,</span></b><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>区别是什么？</span></b></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>JavaScript</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>的数据类型分为基本数据类型和引用数据类型。基本数据类型包括</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Undefined</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>、</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Null</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>、</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Boolean</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>、</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Number</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>、</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>String</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>和</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Symbol</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>（</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>ES6</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>新增），它们是不可变的，存储在栈内存中。引用数据类型主要是</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Object</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>，包括</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Array</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>、</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Function</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>、</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Date</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>等，它们是可变的，存储在堆内存中，变量存储的是引用地址。基本数据类型和引用数据类型的区别在于赋值、比较和内存分配方式。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.1pt;line-height:115%'><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>说一说</span></b><b><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>JS</span></b><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>实现异步的方法？</span></b></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>JavaScript</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>实现异步编程的方法主要有回调函数、</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Promise</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>、</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>async/await</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>、事件监听和发布</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>/</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>订阅模式。回调函数是最传统的异步方法，但可能导致回调地狱。</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Promise</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>提供了一种更优雅的异步处理方式，通过链式调用解决回调嵌套问题。</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>async/await</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>是建立在</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Promise</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>之上的语法糖，使得异步代码写起来像同步代码，提高了可读性。事件监听和发布</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>/</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>订阅模式则通过事件驱动的方式处理异步，适合于复杂的应用场景。</span></p>
  <p class=MsoNormal style='text-indent:24.1pt;line-height:115%'><b><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></b></p>
  </td>
 </tr>
 <tr style='height:77.35pt'>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt;height:77.35pt'>
  <p class=MsoNormal style='margin-left:21.0pt;line-height:115%'><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>说一说创建</span></b><b><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>ajax</span></b><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>过程？</span></b></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>创建</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>AJAX</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>（</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Asynchronous
  JavaScript and XML</span><span style='font-size:12.0pt;line-height:115%;
  font-family:宋体'>）请求的过程通常涉及以下步骤：</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>首先，创建一个</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>XMLHttpRequest</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>对象；然后，使用</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>open</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>方法设置请求类型（如</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>GET</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>或</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>POST</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>）和</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>URL</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>；</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>接下来，可选地设置请求头和配置请求参数（对于</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>POST</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>请求）；</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>之后，定义</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>onreadystatechange</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>事件处理函数来处理服务器响应；</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>最后，调用</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>send</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>方法发送请求。在整个过程中，可以设置</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>timeout</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>属性来处理超时，以及使用</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>abort</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>方法终止请求。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.1pt;line-height:115%'><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>说一说</span></b><b><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>this</span></b><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>指向（普通函数、箭头函数）？</span></b></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>在</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>JavaScript</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>中，</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>this</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>的指向取决于函数的调用方式。在普通函数中，</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>this</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>指向调用函数时的上下文对象，如果在全局作用域中调用，则</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>this</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>指向全局对象（在浏览器中通常是</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>window</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>）。而在箭头函数中，</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>this</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>继承自外围作用域，即箭头函数不会创建自己的</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>this</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>，它的</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>this</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>指向在定义时就已经确定，并且不会改变。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.1pt;line-height:115%'><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>普通函数、箭头函数是什么？</span></b></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>普通函数是</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>JavaScript</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>中的传统函数定义方式，它可以有函数名，可以创建自己的</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>this</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>上下文，可以绑定</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>arguments</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>对象，并且可以作为构造函数使用</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>new</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>关键字创建对象。箭头函数是</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>ES6</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>引入的一种更简洁的函数写法，它没有自己的</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>this</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>、</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>arguments</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>、</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>super</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>或</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>new.target</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>，也不能用作构造函数，箭头函数的语法更简洁，通常用于匿名函数表达式。</span></p>
  <p class=MsoNormal style='margin-left:21.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>const
  add = (a, b) =&gt; a + b;<br>
  const multiplyAndDivide = (a, b) =&gt; {</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;
  const product = a * b;</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;
  const quotient = a / b;</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;
  return { product, quotient };</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>};</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.1pt;line-height:115%'><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>说一下有什么方法可以保持前后端实时通信？</span></b></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>保持前后端实时通信的方法主要有以下几种：</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>WebSocket</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>是一种全双工通信协议，它允许服务器主动发送信息给客户端，实现实时通信；轮询是通过定时发送</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>HTTP</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>请求来模拟实时通信，但效率较低；长轮询是轮询的改进版，服务器在有新数据时才响应请求，减少了请求次数；</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Server-Sent
  Events</span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>（</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>SSE</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>）允许服务器向客户端推送信息，但仅支持单向通信。这些方法中，</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>WebSocket</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>因其高效和实时性而被广泛应用于需要实时互动的应用中。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.1pt;line-height:115%'><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>说一说</span></b><b><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>vue</span></b><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>钩子函数？</span></b></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Vue</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>的钩子函数是</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Vue</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>实例生命周期中的特定阶段调用的函数，它们包括</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>beforeCreate</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>、</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>created</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>、</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>beforeMount</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>、</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>mounted</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>、</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>beforeUpdate</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>、</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>updated</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>、</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>beforeDestroy</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>和</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>destroyed</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>等。这些钩子函数让开发者能够在</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Vue</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>实例的不同阶段添加自己的代码，比如在</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>created</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>钩子中进行数据请求，在</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>mounted</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>钩子中访问到</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>DOM</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>元素，或者在</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>beforeDestroy</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>钩子中进行清理操作，从而更好地控制组件的行为和生命周期。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.1pt;line-height:115%'><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>说一说前端性能优化手段？</span></b></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>前端性能优化手段主要包括减少</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>HTTP</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>请求、使用</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>CDN</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>加速内容分发、压缩</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>CSS</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>和</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>JavaScript</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>文件、利用浏览器缓存、懒加载资源、优化图片大小和格式、减少</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>DOM</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>操作、使用</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Web
  Workers</span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>处理复杂计算、避免重绘和回流、使用</span><span lang=EN-US style='font-size:12.0pt;
  line-height:115%;font-family:"Times New Roman",serif'>CSS3</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>动画代替</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>JavaScript</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>动画等。这些手段的目标是减少页面加载时间、提升用户体验和降低服务器负载。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Vue</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>的生命周期钩子是在</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Vue</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>实例从创建到销毁的整个过程中，在不同阶段提供的回调函数，允许用户在特定时刻执行自定义逻辑。这些钩子函数是</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Vue</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>组件的核心特性之一，它们让开发者能够在组件的不同生命周期阶段进行操作。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>beforeCreate</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>：在实例初始化之后、数据观测和事件</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>/</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>侦听器的配置之前被调用。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>created</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>：在实例创建完成后被立即调用，此时已完成数据观测、属性和方法的运算，</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>$el</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>属性还未显示出来。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>beforeMount</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>：在挂载开始之前被调用，相关的</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>render</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>函数首次被调用。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>mounted</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>：在</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>el</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>被新创建的</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>vm.$el</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>替换，并挂载到实例上去之后调用该钩子。如果根实例挂载了一个文档内元素，当</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>mounted</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>被调用时，子组件也已经被挂载。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>beforeUpdate</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>：数据更新时调用，发生在虚拟</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>DOM</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>打补丁之前。适用于在现有</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>DOM</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>应用更改之前访问它。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>updated</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>：由于数据更改导致的虚拟</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>DOM</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>DOM</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>已经更新，所以可以执行依赖于</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>DOM</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>的操作。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>beforeUnmount</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>：在卸载组件实例之前调用。在这个阶段，实例仍然是完全正常的。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>unmounted</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>：在卸载组件实例之后调用。调用此钩子时，组件实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>NumPy</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>是</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Python</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>中用于科学计算的核心库，提供强大的多维数组对象和一系列操作这些数组的工具。通过</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>NumPy</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>，用户可以高效地创建和处理大型数据集，进行数学运算和逻辑操作。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>NumPy</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>的数组（</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>ndarray</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>）是固定类型的数据容器，支持快速的数组处理和向量化的数学函数，大大提高了数据处理的效率。此外，</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>NumPy</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>还支持数组的形状变换、拼接、切片等操作，使得在</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Python</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>中进行复杂的数值计算变得简单快捷。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Pandas</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>是一个强大的开源数据分析和处理库，专为</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Python</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>编程语言设计，它提供了丰富的数据结构和操作工具，使得数据清洗、转换和分析变得高效便捷。在</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Pandas</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>中，核心的数据结构包括</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Series</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>、</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>DataFrame</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>和</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Panel</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>。</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Series</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>是一维标签数组，用于存储任何类型的数据；</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>DataFrame</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>是二维表格，包含列名称和行索引，常用于数据操作和分析；而</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Panel</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>是三维数据结构，尽管在现代</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Pandas</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>版本中已经不推荐使用。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>创建</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>DataFrame</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>是</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Pandas</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>中的一个基本操作，可以通过多种方式实现，如直接使用列表、字典、</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>NumPy</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>数组等。一旦</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>DataFrame</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>被创建，就可以使用一系列方法进行数据操作，包括筛选（使用</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>loc</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>和</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>iloc</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>）、排序（使用</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>sort_values</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>）、分组（使用</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>groupby</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>）和聚合操作。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>处理缺失数据是数据分析中的常见任务，</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Pandas</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>提供了</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>dropna</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>和</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>fillna</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>等方法来处理这些情况，前者用于删除包含缺失值的行或列，后者用于填充缺失值。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>此外，</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Pandas</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>还支持多种数据合并操作，</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>join</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>是最常用的方法之一，它允许用户根据一个或多个键将不同的</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>DataFrame</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>合并在一起，类似于</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>SQL</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>中的</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>JOIN</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>操作。这些功能使得</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Pandas</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>成为数据科学家和分析师在</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Python</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>中进行数据处理的必备工具。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>pip</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>：</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>pip</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>是</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Python</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>的包管理工具，它提供了对</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Python</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>包的安装、升级、卸载和列出等操作的能力。</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>pip</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>是</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Python</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>社区推荐的包管理工具，它简化了</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Python</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>包的安装过程，使得用户可以轻松地管理和维护项目依赖。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>virtualenv</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>：</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>virtualenv</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>是一个工具，它允许用户创建隔离的</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Python</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>环境。通过这种方式，可以避免不同项目之间依赖关系的冲突，并且可以在没有管理员权限的情况下安装包。每个</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>virtualenv</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>都是一个独立的</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Python</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>解释器和库集合，使得项目环境更加可控和可复制。</span></p>
  <p class=MsoNormal style='line-height:115%'><span lang=EN-US
  style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='line-height:115%'><b><span lang=EN-US
  style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Python
  </span></b><b><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>中的数据结构：</span></b></p>
  <p class=MsoNormal style='margin-left:19.85pt;text-indent:0cm;line-height:
  115%'><span lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:
  "Times New Roman",serif'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;
  </span></span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>列表（</span><span lang=EN-US style='font-size:12.0pt;line-height:115%;
  font-family:"Times New Roman",serif'>List</span><span style='font-size:12.0pt;
  line-height:115%;font-family:宋体'>）：列表是</span><span lang=EN-US
  style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Python</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>中的一种有序集合，可以包含不同类型的元素。列表是可变的，这意味着可以修改、添加或删除列表中的元素。</span></p>
  <p class=MsoNormal style='margin-left:19.85pt;text-indent:0cm;line-height:
  115%'><span lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:
  "Times New Roman",serif'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;
  </span></span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>元组（</span><span lang=EN-US style='font-size:12.0pt;line-height:115%;
  font-family:"Times New Roman",serif'>Tuple</span><span style='font-size:12.0pt;
  line-height:115%;font-family:宋体'>）：元组与列表类似，也是有序集合，但它是不可变的。一旦创建了元组，就不能修改它的内容。</span></p>
  <p class=MsoNormal style='margin-left:19.85pt;text-indent:0cm;line-height:
  115%'><span lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:
  "Times New Roman",serif'>3.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;
  </span></span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>字典（</span><span lang=EN-US style='font-size:12.0pt;line-height:115%;
  font-family:"Times New Roman",serif'>Dictionary</span><span style='font-size:
  12.0pt;line-height:115%;font-family:宋体'>）：字典是一个键值对的集合，其中每个键都是唯一的。字典是无序的，并且可以快速地通过键来访问对应的值。字典是可变的，可以添加、删除和修改键值对。</span></p>
  <p class=MsoNormal style='margin-left:19.85pt;text-indent:0cm;line-height:
  115%'><span lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:
  "Times New Roman",serif'>4.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;
  </span></span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>集合（</span><span lang=EN-US style='font-size:12.0pt;line-height:115%;
  font-family:"Times New Roman",serif'>Set</span><span style='font-size:12.0pt;
  line-height:115%;font-family:宋体'>）：集合是一个无序的、不包含重复元素的集合。集合是可变的，但只能包含不可变（不可变意味着不可修改）的数据类型，如整数、浮点数、字符串、元组等。</span></p>
  <p class=MsoNormal style='line-height:115%'><b><span lang=EN-US
  style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Python
  </span></b><b><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>中的列表、元组、字典和集合的区别：</span></b></p>
  <p class=MsoNormal style='margin-left:36.0pt;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  </span></span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>可变性：</span></p>
  <p class=MsoNormal style='margin-left:72.0pt;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp; </span></span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>列表：可变，可以修改、添加或删除元素。</span></p>
  <p class=MsoNormal style='margin-left:72.0pt;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp; </span></span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>元组：不可变，一旦创建就不能修改。</span></p>
  <p class=MsoNormal style='margin-left:72.0pt;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp; </span></span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>字典：可变，可以添加、删除和修改键值对。</span></p>
  <p class=MsoNormal style='margin-left:72.0pt;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp; </span></span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>集合：可变，可以添加和删除元素，但不能修改已存在的元素（因为集合中的元素是不可变的）。</span></p>
  <p class=MsoNormal style='margin-left:36.0pt;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  </span></span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>有序性：</span></p>
  <p class=MsoNormal style='margin-left:72.0pt;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp; </span></span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>列表：有序，元素按照插入顺序排列。</span></p>
  <p class=MsoNormal style='margin-left:72.0pt;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp; </span></span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>元组：有序，元素按照插入顺序排列。</span></p>
  <p class=MsoNormal style='margin-left:72.0pt;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp; </span></span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>字典：在</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Python
  3.7+</span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>中，字典是有序的，键值对的插入顺序被保留。但在</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Python
  3.6</span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>及之前版本中，字典是无序的。</span></p>
  <p class=MsoNormal style='margin-left:72.0pt;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp; </span></span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>集合：无序，元素没有特定的顺序。</span></p>
  <p class=MsoNormal style='margin-left:36.0pt;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  </span></span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>元素唯一性：</span></p>
  <p class=MsoNormal style='margin-left:72.0pt;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp; </span></span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>列表：可以包含重复的元素。</span></p>
  <p class=MsoNormal style='margin-left:72.0pt;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp; </span></span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>元组：可以包含重复的元素。</span></p>
  <p class=MsoNormal style='margin-left:72.0pt;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp; </span></span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>字典：键必须是唯一的，值可以重复。</span></p>
  <p class=MsoNormal style='margin-left:72.0pt;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp; </span></span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>集合：元素必须是唯一的，不允许重复。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='line-height:115%'><b><span lang=EN-US
  style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Java
  </span></b><b><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>中的数据结构及其区别：</span></b></p>
  <p class=MsoNormal style='margin-left:2.85pt;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:
  "Times New Roman",serif'>1.</span><span style='font-size:12.0pt;line-height:
  115%;font-family:宋体'>数组（</span><span lang=EN-US style='font-size:12.0pt;
  line-height:115%;font-family:"Times New Roman",serif'>Array</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>）：</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Java</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>中的数组是固定长度的有序集合，可以包含基本数据类型或对象。数组在创建时需要指定长度，且长度不可变。</span></p>
  <p class=MsoNormal style='margin-left:2.85pt;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:
  "Times New Roman",serif'>2.</span><span lang=EN-US style='font-size:12.0pt;
  line-height:115%;font-family:"Times New Roman",serif'>ArrayList</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>：</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>ArrayList</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>是</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Java</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>中的一个可调整大小的数组实现，属于</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>List</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>接口的实现。它可以动态地添加和删除元素，但只能包含对象，不能包含基本数据类型。</span></p>
  <p class=MsoNormal style='margin-left:2.85pt;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:
  "Times New Roman",serif'>3.</span><span lang=EN-US style='font-size:12.0pt;
  line-height:115%;font-family:"Times New Roman",serif'>LinkedList</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>：</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>LinkedList</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>是</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Java</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>中的另一个</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>List</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>接口的实现，它通过双向链表实现。与</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>ArrayList</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>相比，</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>LinkedList</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>在插入和删除元素时通常更高效，但在随机访问元素时效率较低。</span></p>
  <p class=MsoNormal style='margin-left:2.85pt;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:
  "Times New Roman",serif'>4.</span><span lang=EN-US style='font-size:12.0pt;
  line-height:115%;font-family:"Times New Roman",serif'>HashMap</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>：</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>HashMap</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>是</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Java</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>中的一个基于哈希表的</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Map</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>实现，用于存储键值对。它是无序的，并且允许一个键对应一个值。</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>HashMap</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>中的键必须是唯一的。</span></p>
  <p class=MsoNormal style='margin-left:2.85pt;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:
  "Times New Roman",serif'>5.</span><span lang=EN-US style='font-size:12.0pt;
  line-height:115%;font-family:"Times New Roman",serif'>HashSet</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>：</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>HashSet</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>是</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Java</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>中的一个基于</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>HashMap</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>实现的</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Set</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>接口的实现，用于存储不包含重复元素的集合。</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>HashSet</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>是无序的，并且元素必须是唯一的。</span></p>
  <p class=MsoNormal style='margin-left:2.85pt;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:
  "Times New Roman",serif'>6.</span><span lang=EN-US style='font-size:12.0pt;
  line-height:115%;font-family:"Times New Roman",serif'>TreeSet</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>：</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>TreeSet</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>是</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Java</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>中的</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Set</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>接口的实现，它基于红黑树结构，可以确保元素处于排序状态。</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>TreeSet</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>中的元素是有序的，且必须是唯一的。</span></p>
  <p class=MsoNormal style='margin-left:2.85pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='line-height:115%'><span style='font-size:12.0pt;
  line-height:115%;font-family:宋体'>列表推导式（</span><span lang=EN-US
  style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>List
  Comprehensions</span><span style='font-size:12.0pt;line-height:115%;
  font-family:宋体'>）：</span><span lang=EN-US style='font-size:12.0pt;line-height:
  115%;font-family:"Times New Roman",serif'>&nbsp;</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>列表推导式是</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Python</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>中一种优雅且简洁的方式来创建列表。它将一个表达式与一个或多个</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>for</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>循环组合起来，并可选地包含一个</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>if</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>条件。列表推导式可以快速生成列表，其语法通常比等效的循环更加紧凑和易于理解。以下是一个例子，它生成了一个包含</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>0</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>到</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>9</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>的平方数的列表：</span></p>
  <p class=MsoNormal style='text-indent:24.1pt;line-height:115%'><b><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Python</span></b><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>：</span></b><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>squares
  = [x**2 for x in range(10)]</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>在这个例子中，</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>x**2</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>是表达式，</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>for
  x in range(10)</span><span style='font-size:12.0pt;line-height:115%;
  font-family:宋体'>是循环，它遍历</span><span lang=EN-US style='font-size:12.0pt;
  line-height:115%;font-family:"Times New Roman",serif'>range(10)</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>生成的</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>0</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>到</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>9</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>的序列，并将每个数的平方添加到新列表</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>squares</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>中。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='line-height:115%'><b><span lang=EN-US
  style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Python</span></b><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>中的元组和列表的区别：</span></b></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>可变性：列表是可变的，可以修改、添加或删除其中的元素；而元组是不可变的，一旦创建就不能更改。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>语法：列表使用方括号</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>[]</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>创建，而元组使用圆括号</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>(
  )</span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>创建。空的元组可以简单地写作</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>(
  )</span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>，而空的列表写作</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>[]</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>用途：列表通常用于存储可变的数据集合，而元组用于存储不可变的数据集合，如数据库记录。</span></p>
  <p class=MsoNormal style='line-height:115%'><b><span lang=EN-US
  style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></b></p>
  <p class=MsoNormal style='line-height:115%'><b><span lang=EN-US
  style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Python</span></b><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>中的字典和集合的区别：</span></b></p>
  <p class=MsoNormal style='line-height:115%'><span style='font-size:12.0pt;
  line-height:115%;font-family:宋体'>数据结构：字典是一个键值对的集合，每个键都是唯一的，用于快速检索值；集合是一个无序的、不包含重复元素的集合。</span></p>
  <p class=MsoNormal style='line-height:115%'><span style='font-size:12.0pt;
  line-height:115%;font-family:宋体'>键值对：字典中的每个元素都是一个键值对，而集合只包含单个元素。</span></p>
  <p class=MsoNormal style='line-height:115%'><span style='font-size:12.0pt;
  line-height:115%;font-family:宋体'>访问方式：字典可以通过键来访问值，而集合不支持键值访问，只能检查元素是否存在于集合中。</span></p>
  <p class=MsoNormal style='line-height:115%'><b><span lang=EN-US
  style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></b></p>
  <p class=MsoNormal style='line-height:115%'><b><span lang=EN-US
  style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Python</span></b><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>中的深拷贝和浅拷贝的区别：</span></b></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>浅拷贝（</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Shallow
  Copy</span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>）：创建一个新对象，但它包含对原始对象中包含的项的引用。如果原始对象中的项是可变的，那么在浅拷贝中修改这些项也会影响到原始对象。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>深拷贝（</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Deep
  Copy</span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>）：创建一个新对象，并递归地复制原始对象中包含的所有项。这意味着深拷贝产生的新对象与原始对象完全独立，对深拷贝中的项的修改不会影响到原始对象。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>在</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Python</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>中，可以使用</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>copy</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>模块的</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>copy()</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>函数进行浅拷贝，使用</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>deepcopy()</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>函数进行深拷贝。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>面向对象编程（</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>OOP</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>）是一种编程范式，它使用对象和类来设计软件。以下是面向对象编程的三个基本特性及其相关概念的整理和补充：</span></p>
  <p class=MsoNormal style='margin-left:22.7pt;text-indent:24.1pt;line-height:
  115%'><span lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:
  "Times New Roman",serif'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;
  </span></span><b><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>封装（</span></b><b><span lang=EN-US style='font-size:12.0pt;line-height:
  115%;font-family:"Times New Roman",serif'>Encapsulation</span></b><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>）</span></b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>：</span></p>
  <p class=MsoNormal style='margin-left:2.0cm;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・ </span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>封装是指将数据（属性）和操作数据的函数（方法）封装在一个类中，形成一个统一的操作单元。</span></p>
  <p class=MsoNormal style='margin-left:2.0cm;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・ </span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>目的是隐藏对象的内部状态和实现细节，仅通过公共接口暴露必要的功能。</span></p>
  <p class=MsoNormal style='margin-left:2.0cm;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・ </span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>这有助于提高代码的安全性和可维护性。</span></p>
  <p class=MsoNormal style='margin-left:17.0pt;text-indent:24.1pt;line-height:
  115%'><span lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:
  "Times New Roman",serif'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  </span></span><b><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>继承（</span></b><b><span lang=EN-US style='font-size:12.0pt;line-height:
  115%;font-family:"Times New Roman",serif'>Inheritance</span></b><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>）</span></b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>：</span></p>
  <p class=MsoNormal style='margin-left:2.0cm;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・ </span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>继承允许一个类（子类）继承另一个类（父类）的属性和方法，从而实现代码的复用。</span></p>
  <p class=MsoNormal style='margin-left:2.0cm;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・ </span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>子类可以扩展或修改继承来的行为，也可以添加新的属性和方法。</span></p>
  <p class=MsoNormal style='margin-left:2.0cm;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・ </span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>继承有助于建立类之间的关系，形成层次结构。</span></p>
  <p class=MsoNormal style='margin-left:17.0pt;text-indent:24.1pt;line-height:
  115%'><span lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:
  "Times New Roman",serif'>3.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  </span></span><b><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>多态（</span></b><b><span lang=EN-US style='font-size:12.0pt;line-height:
  115%;font-family:"Times New Roman",serif'>Polymorphism</span></b><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>）</span></b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>：</span></p>
  <p class=MsoNormal style='margin-left:2.0cm;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・ </span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>多态是指同一个行为具有多个不同表现形式或形态的能力。</span></p>
  <p class=MsoNormal style='margin-left:2.0cm;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・ </span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>在</span><span lang=EN-US style='font-size:12.0pt;line-height:115%;
  font-family:"Times New Roman",serif'>OOP</span><span style='font-size:12.0pt;
  line-height:115%;font-family:宋体'>中，多态通常通过继承和虚函数实现，允许使用一个接口来定义不同的实现方式。</span></p>
  <p class=MsoNormal style='margin-left:2.0cm;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・ </span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>这使得在编码时可以编写更通用、更灵活的代码。</span></p>
  <p class=MsoNormal style='margin-left:17.0pt;text-indent:24.1pt;line-height:
  115%'><span lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:
  "Times New Roman",serif'>4.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  </span></span><b><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>虚函数和纯虚函数</span></b><span style='font-size:12.0pt;line-height:115%;
  font-family:宋体'>：</span></p>
  <p class=MsoNormal style='margin-left:2.0cm;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・ </span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>虚函数是在基类中被声明为虚的成员函数，可以在派生类中被重写以实现多态。</span></p>
  <p class=MsoNormal style='margin-left:2.0cm;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・ </span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>纯虚函数是在基类中没有具体实现的虚函数，它要求派生类必须提供具体的实现。</span></p>
  <p class=MsoNormal style='margin-left:2.0cm;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・ </span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>包含纯虚函数的类称为抽象类，不能直接实例化。</span></p>
  <p class=MsoNormal style='margin-left:17.0pt;text-indent:24.1pt;line-height:
  115%'><span lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:
  "Times New Roman",serif'>5.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  </span></span><b><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>重载（</span></b><b><span lang=EN-US style='font-size:12.0pt;line-height:
  115%;font-family:"Times New Roman",serif'>Overloading</span></b><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>）和覆盖（</span></b><b><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Overriding</span></b><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>）</span></b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>：</span></p>
  <p class=MsoNormal style='margin-left:2.0cm;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・ </span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>重载是指在同一个作用域内，多个函数具有相同的名字但参数列表不同（参数数量或类型不同）。</span></p>
  <p class=MsoNormal style='margin-left:2.0cm;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・ </span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>覆盖是指子类提供一个与父类中同名、同参数列表的函数，以重写父类的虚函数实现。</span></p>
  <p class=MsoNormal style='margin-left:17.0pt;text-indent:24.1pt;line-height:
  115%'><span lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:
  "Times New Roman",serif'>6.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  </span></span><b><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>构造函数和析构函数</span></b><span style='font-size:12.0pt;line-height:115%;
  font-family:宋体'>：</span></p>
  <p class=MsoNormal style='margin-left:2.0cm;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・ </span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>构造函数在创建对象时自动调用，用于初始化对象的成员变量。</span></p>
  <p class=MsoNormal style='margin-left:2.0cm;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・ </span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>析构函数在对象生命周期结束时自动调用，用于执行清理工作，如释放分配的资源。</span></p>
  <p class=MsoNormal style='margin-left:17.0pt;text-indent:24.1pt;line-height:
  115%'><span lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:
  "Times New Roman",serif'>7.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  </span></span><b><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>友元函数和友元类</span></b><span style='font-size:12.0pt;line-height:115%;
  font-family:宋体'>：</span></p>
  <p class=MsoNormal style='margin-left:2.0cm;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・ </span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>友元函数可以访问类的私有和保护成员，即使它不是类的成员函数。</span></p>
  <p class=MsoNormal style='margin-left:2.0cm;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・ </span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>友元类可以访问另一个类的所有成员，包括私有成员。</span></p>
  <p class=MsoNormal style='margin-left:17.0pt;text-indent:24.1pt;line-height:
  115%'><span lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:
  "Times New Roman",serif'>8.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  </span></span><b><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>静态成员变量和静态成员函数</span></b><span style='font-size:12.0pt;line-height:115%;
  font-family:宋体'>：</span></p>
  <p class=MsoNormal style='margin-left:2.0cm;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・ </span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>静态成员变量属于类本身，而不是类的任何一个实例，所有对象共享同一个静态成员变量。</span></p>
  <p class=MsoNormal style='margin-left:2.0cm;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・ </span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>静态成员函数没有</span><span lang=EN-US style='font-size:12.0pt;line-height:115%;
  font-family:"Times New Roman",serif'>this</span><span style='font-size:12.0pt;
  line-height:115%;font-family:宋体'>指针，因此只能访问静态成员变量和其他静态成员函数。</span></p>
  <p class=MsoNormal style='margin-left:17.0pt;text-indent:24.1pt;line-height:
  115%'><span lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:
  "Times New Roman",serif'>9.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  </span></span><b><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>设计模式</span></b><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>：</span></p>
  <p class=MsoNormal style='margin-left:2.0cm;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・ </span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>设计模式是解决软件设计中常见问题的通用可重用解决方案。</span></p>
  <p class=MsoNormal style='margin-left:2.0cm;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・ </span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>常见的设计模式包括单例模式（确保一个类只有一个实例）、工厂模式（用于创建对象）、观察者模式（对象间的一对多依赖关系）、策略模式（定义了算法家族，分别封装起来，使它们之间可以互相替换）等。</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>恶意用户检测平台</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>:</span></p>
  <p class=MsoNormal style='text-indent:24.1pt;line-height:115%'><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>您提到使用了图神经网络（</span></b><b><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>GNN</span></b><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>）技术，请问您具体使用了哪种</span></b><b><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>GNN</span></b><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>模型？</span></b></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>CARE-GNN
  </span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>并不是一个特定的</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>
  GNN </span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>模型，而是一个框架，它可以在现有</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>
  GNN </span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>模型的基础上添加三个独特的模块来增强其对抗欺诈者伪装的能力。论文中提到，</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>CARE-GNN
  </span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>可以与任何基于邻居聚合的</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>
  GNN </span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>模型结合使用，例如</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>
  GCN</span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>、</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>GAT
  </span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>和</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>
  GraphSAGE</span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>您如何评估模型的性能？使用了哪些指标？</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>论文中使用了两个指标来评估模型在欺诈检测任务上的性能：</span></p>
  <p class=MsoNormal style='margin-left:36.0pt;text-indent:24.1pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  </span></span><b><span lang=EN-US style='font-size:12.0pt;line-height:115%;
  font-family:"Times New Roman",serif'>ROC-AUC (AUC</span></b><span lang=EN-US
  style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>)</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>：</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>AUC
  </span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>是一种衡量分类器整体性能的指标，它考虑了所有实例的预测概率排名，可以消除类别不平衡的影响。</span></p>
  <p class=MsoNormal style='margin-left:36.0pt;text-indent:24.1pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  </span></span><b><span lang=EN-US style='font-size:12.0pt;line-height:115%;
  font-family:"Times New Roman",serif'>Recall</span></b><span style='font-size:
  12.0pt;line-height:115%;font-family:宋体'>：</span><span lang=EN-US
  style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Recall
  </span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>是指正确识别出的欺诈者数量与所有欺诈者数量的比例，它关注于模型对欺诈者的识别能力。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>企业人力需求预测系统</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>:</span></p>
  <p class=MsoNormal style='text-indent:24.1pt;line-height:115%'><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>您提到了使用</span></b><b><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>LSTM</span></b><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>和</span></b><b><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Transformer</span></b><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>模型进行时间序列预测，请问您如何选择模型？</span></b></p>
  <p class=MsoNormal style='margin-left:36.0pt;text-indent:24.1pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  </span></span><b><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>数据特点</span></b><span lang=EN-US style='font-size:12.0pt;line-height:115%;
  font-family:"Times New Roman",serif'>: </span><span style='font-size:12.0pt;
  line-height:115%;font-family:宋体'>首先，我会分析数据的特点，例如时间序列的长度、数据的平稳性、是否存在周期性等。</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>LSTM</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>更适合处理长时间序列和具有长期依赖关系的数据，而</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Transformer</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>更适合处理短时间序列和具有并行计算能力的数据。</span></p>
  <p class=MsoNormal style='margin-left:36.0pt;text-indent:24.1pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  </span></span><b><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>模型性能</span></b><span lang=EN-US style='font-size:12.0pt;line-height:115%;
  font-family:"Times New Roman",serif'>: </span><span style='font-size:12.0pt;
  line-height:115%;font-family:宋体'>其次，我会比较</span><span lang=EN-US
  style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>LSTM</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>和</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Transformer</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>在不同时间序列预测任务上的性能表现，例如预测准确率、模型收敛速度等。</span></p>
  <p class=MsoNormal style='margin-left:36.0pt;text-indent:24.1pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  </span></span><b><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>计算资源</span></b><span lang=EN-US style='font-size:12.0pt;line-height:115%;
  font-family:"Times New Roman",serif'>: </span><span style='font-size:12.0pt;
  line-height:115%;font-family:宋体'>最后，我会考虑计算资源的限制，例如内存和计算能力。</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>LSTM</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>模型通常需要更多的内存和计算资源，而</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Transformer</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>模型可以并行计算，效率更高。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  <p class=MsoNormal style='text-indent:24.1pt;line-height:115%'><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>您如何处理模型训练过程中的过拟合或欠拟合问题？</span></b></p>
  <p class=MsoNormal style='margin-left:36.0pt;text-indent:24.1pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  </span></span><b><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>数据增强</span></b><span lang=EN-US style='font-size:12.0pt;line-height:115%;
  font-family:"Times New Roman",serif'>: </span><span style='font-size:12.0pt;
  line-height:115%;font-family:宋体'>我会尝试使用数据增强技术，例如添加噪声、插值等，来增加训练数据的多样性，从而避免过拟合。</span></p>
  <p class=MsoNormal style='margin-left:36.0pt;text-indent:24.1pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  </span></span><b><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>正则化</span></b><span lang=EN-US style='font-size:12.0pt;line-height:115%;
  font-family:"Times New Roman",serif'>: </span><span style='font-size:12.0pt;
  line-height:115%;font-family:宋体'>我会使用正则化技术，例如</span><span lang=EN-US
  style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>L1</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>或</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>L2</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>正则化，来限制模型的复杂度，从而避免过拟合。</span></p>
  <p class=MsoNormal style='margin-left:36.0pt;text-indent:24.1pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  </span></span><b><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>超参数调整</span></b><span lang=EN-US style='font-size:12.0pt;line-height:
  115%;font-family:"Times New Roman",serif'>: </span><span style='font-size:
  12.0pt;line-height:115%;font-family:宋体'>我会调整模型的超参数，例如学习率、批大小等，来找到最佳的模型配置。</span></p>
  <p class=MsoNormal style='margin-left:36.0pt;text-indent:24.1pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  </span></span><b><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>交叉验证</span></b><span lang=EN-US style='font-size:12.0pt;line-height:115%;
  font-family:"Times New Roman",serif'>: </span><span style='font-size:12.0pt;
  line-height:115%;font-family:宋体'>我会使用交叉验证来评估模型的泛化能力，从而避免欠拟合。</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  <p class=MsoNormal style='text-indent:24.1pt;line-height:115%'><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>您的系统如何进行数据可视化？使用了哪些工具？</span></b></p>
  <p class=MsoNormal style='margin-left:0cm;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>数据可视化工具</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>:
  </span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>我会使用一些常见的数据可视化工具，例如</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Matplotlib</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>、</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Seaborn</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>、</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Plotly</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>等，来绘制时间序列图、预测结果图、残差图等。</span></p>
  <p class=MsoNormal style='margin-left:0cm;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>可视化内容</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>:
  </span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>我会根据具体的任务需求，选择合适的可视化内容，例如：</span></p>
  <p class=MsoNormal style='margin-left:0cm;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・ </span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>时间序列图</span><span lang=EN-US style='font-size:12.0pt;line-height:115%;
  font-family:"Times New Roman",serif'>: </span><span style='font-size:12.0pt;
  line-height:115%;font-family:宋体'>展示原始时间序列数据，以及模型的预测结果。</span></p>
  <p class=MsoNormal style='margin-left:0cm;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・ </span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>残差图</span><span lang=EN-US style='font-size:12.0pt;line-height:115%;
  font-family:"Times New Roman",serif'>: </span><span style='font-size:12.0pt;
  line-height:115%;font-family:宋体'>展示模型的预测结果与实际值之间的差异，用于评估模型的预测精度。</span></p>
  <p class=MsoNormal style='margin-left:0cm;text-indent:24.0pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・ </span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>特征重要性图</span><span lang=EN-US style='font-size:12.0pt;line-height:115%;
  font-family:"Times New Roman",serif'>: </span><span style='font-size:12.0pt;
  line-height:115%;font-family:宋体'>展示不同特征对模型预测结果的影响程度，用于分析模型的内部机制。</span></p>
  <p class=MsoNormal style='line-height:115%'><b><span lang=EN-US
  style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></b></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.1pt;line-height:115%'><b><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>1.
  </span></b><b><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>除了</span></b><b><span lang=EN-US style='font-size:12.0pt;line-height:
  115%;font-family:"Times New Roman",serif'>Pandas</span></b><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>和</span></b><b><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>NumPy</span></b><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>，您还熟悉哪些数据科学相关的库？</span></b></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>除了</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Pandas</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>和</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>NumPy</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>，数据科学领域中还有许多非常重要和常用的库，我可以列出一些并简要说明它们的作用：</span></p>
  <p class=MsoNormal style='margin-left:36.0pt;text-indent:24.1pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  </span></span><b><span lang=EN-US style='font-size:12.0pt;line-height:115%;
  font-family:"Times New Roman",serif'>Matplotlib &amp; Seaborn</span></b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>：这两个库常用于数据的可视化。</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Matplotlib
  </span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>是一个非常强大的绘图库，适用于创建静态图表。</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Seaborn
  </span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>基于</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>
  Matplotlib</span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>，提供更高级的接口，能够生成更美观的统计图形，特别适合数据探索与展示。</span></p>
  <p class=MsoNormal style='margin-left:36.0pt;text-indent:24.1pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  </span></span><b><span lang=EN-US style='font-size:12.0pt;line-height:115%;
  font-family:"Times New Roman",serif'>SciPy</span></b><span style='font-size:
  12.0pt;line-height:115%;font-family:宋体'>：这是一个用于科学和工程计算的库，包含了大量的数学、科学、工程函数，例如线性代数、优化、积分等。它通常与</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>
  NumPy </span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>配合使用。</span></p>
  <p class=MsoNormal style='margin-left:36.0pt;text-indent:24.1pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  </span></span><b><span lang=EN-US style='font-size:12.0pt;line-height:115%;
  font-family:"Times New Roman",serif'>Scikit-learn</span></b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>：这是一个非常流行的机器学习库，提供了丰富的机器学习算法，包括分类、回归、聚类、降维等。</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Scikit-learn
  </span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>还包括数据预处理、模型评估和调优的功能，非常适合进行机器学习的快速实验。</span></p>
  <p class=MsoNormal style='margin-left:36.0pt;text-indent:24.1pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  </span></span><b><span lang=EN-US style='font-size:12.0pt;line-height:115%;
  font-family:"Times New Roman",serif'>TensorFlow / PyTorch</span></b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>：这两个库是深度学习领域的核心工具。</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>TensorFlow
  </span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>是由</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>
  Google </span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>开发的，用于深度学习的框架，</span><span lang=EN-US style='font-size:12.0pt;line-height:
  115%;font-family:"Times New Roman",serif'>PyTorch </span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>则由</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>
  Facebook </span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>开发，具有更灵活和动态的计算图，适合做研究与原型开发。</span></p>
  <p class=MsoNormal style='margin-left:36.0pt;text-indent:24.1pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  </span></span><b><span lang=EN-US style='font-size:12.0pt;line-height:115%;
  font-family:"Times New Roman",serif'>Statsmodels</span></b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>：用于统计建模和计量经济学分析，提供了回归分析、假设检验、时间序列分析等功能，适用于做一些更细致的统计建模和推断分析。</span></p>
  <p class=MsoNormal style='margin-left:36.0pt;text-indent:24.1pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  </span></span><b><span lang=EN-US style='font-size:12.0pt;line-height:115%;
  font-family:"Times New Roman",serif'>Dask</span></b><span style='font-size:
  12.0pt;line-height:115%;font-family:宋体'>：用于大规模数据计算，类似于</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>
  Pandas</span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>，但是能够处理比内存大得多的数据集。它通过并行化计算来加速处理。</span></p>
  <p class=MsoNormal style='margin-left:36.0pt;text-indent:24.1pt;line-height:
  115%'><span lang=EN-US style='font-size:10.0pt;line-height:115%;font-family:
  Symbol'>・<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  </span></span><b><span lang=EN-US style='font-size:12.0pt;line-height:115%;
  font-family:"Times New Roman",serif'>SQLAlchemy</span></b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>：用于与数据库交互的库。通过它，您可以在</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>
  Python </span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>中执行</span><span lang=EN-US style='font-size:12.0pt;line-height:115%;
  font-family:"Times New Roman",serif'> SQL </span><span style='font-size:12.0pt;
  line-height:115%;font-family:宋体'>查询，访问并操作关系型数据库（如</span><span lang=EN-US
  style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>
  MySQL</span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>、</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>PostgreSQL</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>、</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>SQLite
  </span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>等）。</span></p>
  <p class=MsoNormal style='line-height:115%'><span lang=EN-US
  style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal><span lang=EN-US style='font-family:"Times New Roman",serif'>&nbsp;</span></p>

<div align=center>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='border-collapse:collapse;border:none'>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.1pt;line-height:115%'><b><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>什么是自动装箱和拆箱？</span></b></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>自动装箱：指的是将一个基本数据类型的数据自动转换为对应的包装类对象。例如，将</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>int</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>类型的值自动转换为</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Integer</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>对象。在</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Java</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>中，当你将一个基本数据类型值赋给其包装类类型的变量时，编译器会自动创建一个包装类的对象并将该基本数据类型的值存储进去。</span><span
  style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>
  </span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>示例：</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Integer
  a = 10; // </span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>自动装箱</span><span lang=EN-US style='font-size:12.0pt;line-height:115%;
  font-family:"Times New Roman",serif'>, </span><span style='font-size:12.0pt;
  line-height:115%;font-family:宋体'>编译器会将其转换为</span><span lang=EN-US
  style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>
  Integer.valueOf(10)</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>自动拆箱：这是自动装箱的反向操作，指的是将包装类对象中的值自动转换回对应的基本数据类型。当使用包装类对象的地方需要一个基本数据类型的值时，编译器会自动进行拆箱操作，将包装类对象转换为基本数据类型。</span><span
  style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>
  </span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>示例：</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Integer
  a = new Integer(10);</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>int
  i = a; // </span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>自动拆箱</span><span lang=EN-US style='font-size:12.0pt;line-height:115%;
  font-family:"Times New Roman",serif'>, </span><span style='font-size:12.0pt;
  line-height:115%;font-family:宋体'>编译器会将其转换为</span><span lang=EN-US
  style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>
  a.intValue()</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>String
  a = &quot;hello&quot;;</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>String
  b = &quot;hello&quot;;</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>&nbsp;</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>System.out.println(a
  == b); // </span><span style='font-size:12.0pt;line-height:115%;font-family:
  宋体'>输出</span><span lang=EN-US style='font-size:12.0pt;line-height:115%;
  font-family:"Times New Roman",serif'> false</span><span style='font-size:
  12.0pt;line-height:115%;font-family:宋体'>，因为</span><span lang=EN-US
  style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>a</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>和</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>b</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>是两个不同的对象引用</span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>System.out.println(a.equals(b));
  // </span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>输出</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>
  true</span><span style='font-size:12.0pt;line-height:115%;font-family:宋体'>，因为</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>a</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>和</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>b</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>的内容相同</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>类（</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Class</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>）：类是面向对象编程中的一个基本概念，它是对一组具有相同属性（成员变量）和行为（方法）的对象的抽象描述。换句话说，类定义了一种数据结构，它包含了数据字段（通常称为属性或成员变量）和方法（函数），用于操作这些数据。</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'><br>
  <br>
  </span></p>
  <p class=MsoNormal style='text-indent:24.0pt;line-height:115%'><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>对象（</span><span
  lang=EN-US style='font-size:12.0pt;line-height:115%;font-family:"Times New Roman",serif'>Object</span><span
  style='font-size:12.0pt;line-height:115%;font-family:宋体'>）：对象是类的一个实例。通过类创建对象的过程叫做实例化。每个对象都有自己的状态（由成员变量的值表示）和行为（通过调用方法实现）。对象是类的具体体现，它将理论上的类定义转化为实际可操作的数据结构。</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>重载（<span
  lang=EN-US>Overloading</span>）和覆盖（<span lang=EN-US>Overriding</span>）是面向对象编程中两个常用的概念，它们的主要区别如下：</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>1.
  </span><span style='font-size:12.0pt;font-family:宋体'>重载（<span lang=EN-US>Overloading</span>）：</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;&nbsp;
  - </span><span style='font-size:12.0pt;font-family:宋体'>发生在同一类中。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;&nbsp;
  - </span><span style='font-size:12.0pt;font-family:宋体'>方法名称相同，但参数列表必须不同（参数个数或类型不同）。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;&nbsp;
  - </span><span style='font-size:12.0pt;font-family:宋体'>返回类型可以相同或不同。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;&nbsp;
  - </span><span style='font-size:12.0pt;font-family:宋体'>主要目的是增加方法的不同行为，使得同一个方法名可以根据不同的参数执行不同的任务。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>2.
  </span><span style='font-size:12.0pt;font-family:宋体'>覆盖（<span lang=EN-US>Overriding</span>）：</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;&nbsp;
  - </span><span style='font-size:12.0pt;font-family:宋体'>发生在子类和父类之间。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;&nbsp;
  - </span><span style='font-size:12.0pt;font-family:宋体'>子类中的方法必须和父类中被覆盖的方法有相同的名称、参数列表和返回类型。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;&nbsp;
  - </span><span style='font-size:12.0pt;font-family:宋体'>覆盖的方法必须具有相同的或更高的访问级别。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;&nbsp;
  - </span><span style='font-size:12.0pt;font-family:宋体'>主要目的是在子类中重写父类的方法，提供具体化的实现。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>简而言之，重载是同一类中多个方法的名称相同但参数不同，而覆盖是子类重新定义了父类中已有的方法。</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><b><span style='font-size:12.0pt;font-family:宋体'>集合框架<span
  lang=EN-US> List, Set, Map </span>之间的区别是什么？ </span></b></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>List</span><span
  style='font-size:12.0pt;font-family:宋体'>、<span lang=EN-US>Set </span>和<span
  lang=EN-US> Map </span>是<span lang=EN-US> Java </span>集合框架中的三个主要部分，它们用于存储和管理对象集合，但各自具有不同的特性和用途：</span></p>
  <ul style='margin-top:0cm' type=disc>
   <li class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:
       宋体'>List</span><span style='font-size:12.0pt;font-family:宋体'>：<span
       lang=EN-US>List </span>是一个有序集合，它按照元素添加的顺序来维护元素。<span lang=EN-US>List </span>允许重复的元素，可以通过索引来访问任何元素，支持插入、删除和替换操作。常见的<span
       lang=EN-US> List </span>实现包括<span lang=EN-US> ArrayList</span>（适合随机访问）和<span
       lang=EN-US> LinkedList</span>（适合频繁的插入和删除操作）。</span></li>
   <li class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:
       宋体'>Set</span><span style='font-size:12.0pt;font-family:宋体'>：<span
       lang=EN-US>Set </span>是一个不包含重复元素的集合，它不保证元素的顺序，无论元素的添加顺序如何，<span
       lang=EN-US>Set </span>中的元素都是无序的。<span lang=EN-US>Set </span>主要用于确保元素的唯一性，常见的<span
       lang=EN-US> Set </span>实现有<span lang=EN-US> HashSet</span>（基于哈希表，快速查找）、<span
       lang=EN-US>LinkedHashSet</span>（保持插入顺序）和<span lang=EN-US> TreeSet</span>（元素排序）。</span></li>
   <li class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:
       宋体'>Map</span><span style='font-size:12.0pt;font-family:宋体'>：<span
       lang=EN-US>Map </span>是一个存储键值对（<span lang=EN-US>key-value pairs</span>）的集合，其中键（<span
       lang=EN-US>Key</span>）是唯一的，而值（<span lang=EN-US>Value</span>）则可以重复。<span
       lang=EN-US>Map </span>不保证键值对的顺序，它的主要用途是通过键来快速检索值。常见的<span lang=EN-US>
       Map </span>实现有<span lang=EN-US> HashMap</span>（基于哈希表，非线程安全）和<span
       lang=EN-US> TreeMap</span>（基于红黑树，可以对键进行排序）</span>。</li>
  </ul>
  <p class=MsoNormal><span lang=EN-US style='font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><b><span lang=EN-US style='font-size:12.0pt;font-family:
  宋体'>ArrayList </span></b><b><span style='font-size:12.0pt;font-family:宋体'>和<span
  lang=EN-US> LinkedList </span>的主要区别是什么？</span></b></p>
  <p class=MsoNormal><b><span lang=EN-US style='font-size:12.0pt;font-family:
  宋体'>ArrayList</span></b><b><span style='font-size:12.0pt;font-family:宋体'>是基于动态数组的数据结构，而<span
  lang=EN-US>LinkedList</span>是基于双向链表的数据结构。主要区别如下：</span></b></p>
  <ul style='margin-top:0cm' type=disc>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>内存分配方式：<span
       lang=EN-US>ArrayList</span>在内存中连续分配空间，而<span lang=EN-US>LinkedList</span>的每个元素都有指向前后节点的指针，因此内存分配是非连续的。</span></li>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>插入和删除操作：<span
       lang=EN-US>ArrayList</span>在数组中间插入或删除元素时，需要移动后续所有元素，成本较高；<span
       lang=EN-US>LinkedList</span>因为元素之间通过指针连接，插入或删除时只需改变指针，成本较低。</span></li>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>随机访问：<span
       lang=EN-US>ArrayList</span>支持随机访问，可以通过索引快速访问任意元素；<span lang=EN-US>LinkedList</span>不支持随机访问，访问特定索引的元素需要从头节点或尾节点开始遍历。</span></li>
  </ul>
  <p class=MsoNormal><span lang=EN-US style='font-family:"Times New Roman",serif'>&nbsp;</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><b><span lang=EN-US style='font-size:12.0pt;font-family:
  宋体'>HashMap </span></b><b><span style='font-size:12.0pt;font-family:宋体'>是如何工作的？</span></b></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>HashMap
  </span><span style='font-size:12.0pt;font-family:宋体'>通过哈希表实现工作，它存储键值对，并允许快速插入和检索。以下是<span
  lang=EN-US>HashMap</span>的工作原理：</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>1.
  </span><span style='font-size:12.0pt;font-family:宋体'>哈希函数：当向<span lang=EN-US>HashMap</span>中插入一个键值对时，首先会使用键对象的<span
  lang=EN-US>`hashCode()`</span>方法计算键的哈希码。这个哈希码随后会被<span lang=EN-US>HashMap</span>的哈希函数处理，以确定键值对在内部数组中的存储位置。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>2.
  </span><span style='font-size:12.0pt;font-family:宋体'>数组与桶：<span lang=EN-US>HashMap</span>内部维护了一个数组，数组的每个槽位（<span
  lang=EN-US>slot</span>）或称为桶（<span lang=EN-US>bucket</span>），用于存储键值对。数组的长度通常是<span
  lang=EN-US>2</span>的幂，这样可以优化哈希函数的性能。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>3.
  </span><span style='font-size:12.0pt;font-family:宋体'>索引计算：计算出的哈希码会通过与数组长度的模运算来确定键值对应该存储在哪个桶中。即<span
  lang=EN-US> `index = hash % arrayLength`</span>。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>4.
  </span><span style='font-size:12.0pt;font-family:宋体'>哈希冲突：如果两个不同的键产生了相同的索引，这种情况称为哈希冲突。<span
  lang=EN-US>HashMap</span>通过链表（在<span lang=EN-US>Java 8</span>之前）或红黑树（在<span
  lang=EN-US>Java 8</span>及以后版本，当链表长度超过一定阈值时）来解决冲突，即在相同索引的桶位置上，所有冲突的键值对会被存储在一个链表或红黑树中。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>5.
  </span><span style='font-size:12.0pt;font-family:宋体'>键值对存储：对于无冲突的情况，键值对直接存储在计算出的索引位置上。对于冲突的情况，键值对会被添加到链表的末尾或红黑树中。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>6.
  </span><span style='font-size:12.0pt;font-family:宋体'>查找元素：当从<span lang=EN-US>HashMap</span>中获取一个元素时，<span
  lang=EN-US>HashMap</span>会使用相同的哈希函数来定位到正确的桶，然后遍历链表或红黑树来查找具有匹配键的元素。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>7.
  </span><span style='font-size:12.0pt;font-family:宋体'>动态扩容：当<span lang=EN-US>HashMap</span>中的元素数量达到一定的负载因子时（默认是<span
  lang=EN-US>0.75</span>乘以当前数组大小），<span lang=EN-US>HashMap</span>会进行扩容操作，数组大小翻倍，并重新计算每个键值对的存储位置，将其重新散列到新数组中。</span></p>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>通过这种方式，<span
  lang=EN-US>HashMap</span>在理想情况下可以在常数时间内（<span lang=EN-US>O(1)</span>）完成插入、删除和查找操作。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>Java</span><span
  style='font-size:12.0pt;font-family:宋体'>中有几种常见的创建线程的方式：</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>1.
  </span><span style='font-size:12.0pt;font-family:宋体'>继承<span lang=EN-US>Thread</span>类并重写<span
  lang=EN-US>run()</span>方法。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>2.
  </span><span style='font-size:12.0pt;font-family:宋体'>实现<span lang=EN-US>Runnable</span>接口并重写<span
  lang=EN-US>run()</span>方法，然后将这个实例传递给<span lang=EN-US>Thread</span>对象。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>3.
  </span><span style='font-size:12.0pt;font-family:宋体'>使用<span lang=EN-US>Executor</span>框架，比如通过<span
  lang=EN-US>Executors</span>类中的方法创建线程池，然后将任务提交给线程池。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>synchronized</span><span
  style='font-size:12.0pt;font-family:宋体'>关键字的作用是保证在同一时刻，只有一个线程可以执行某个方法或代码块，它提供了线程间的互斥机制，防止多个线程同时访问共享资源而引发数据不一致的问题。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>volatile</span><span
  style='font-size:12.0pt;font-family:宋体'>关键字的作用是保证变量的可见性，即当一个线程修改了某个<span
  lang=EN-US>volatile</span>变量的值，这个修改对其他线程来说是立即可见的。它确保了变量读写的可见性，但并不保证操作的原子性。<span
  lang=EN-US>volatile</span>通常用于在多线程环境中，对某个变量进行频繁的读写操作时，确保变量值的及时更新。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-family:"Times New Roman",serif'>&nbsp;</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-family:"Times New Roman",serif'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>JVM
  </span><span style='font-size:12.0pt;font-family:宋体'>内存结构主要由以下几个部分组成：</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>1.
  </span><span style='font-size:12.0pt;font-family:宋体'>方法区（<span lang=EN-US>Method
  Area</span>）：存储已被虚拟机加载的类信息、常量、静态变量等数据。在<span lang=EN-US> Java 8 </span>及之前版本，方法区也被称为永久代（<span
  lang=EN-US>PermGen</span>），从<span lang=EN-US> Java 8 </span>开始，使用元空间（<span
  lang=EN-US>Metaspace</span>）来替代永久代，元空间使用本地内存。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>2.
  </span><span style='font-size:12.0pt;font-family:宋体'>堆（<span lang=EN-US>Heap</span>）：是<span
  lang=EN-US> JVM </span>管理的最大内存区域，用于存储对象实例和数组等。堆分为新生代（<span lang=EN-US>Young
  Generation</span>）和老年代（<span lang=EN-US>Old Generation</span>）。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>3.
  </span><span style='font-size:12.0pt;font-family:宋体'>栈（<span lang=EN-US>Stack</span>）：每个线程运行时都有一个栈，用于存储局部变量、方法调用等信息。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>4.
  </span><span style='font-size:12.0pt;font-family:宋体'>程序计数器（<span lang=EN-US>Program
  Counter Register</span>）：是线程私有的，每个线程都有一个程序计数器，是用来存储指向下一条指令的地址。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>5.
  </span><span style='font-size:12.0pt;font-family:宋体'>本地方法栈（<span lang=EN-US>Native
  Method Stack</span>）：为虚拟机使用到的<span lang=EN-US> Native </span>方法服务。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>垃圾回收机制主要工作如下：</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>1.
  </span><span style='font-size:12.0pt;font-family:宋体'>标记<span lang=EN-US>-</span>清除（<span
  lang=EN-US>Mark-Sweep</span>）：首先标记出所有活动的对象，然后清除未被标记的对象。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>2.
  </span><span style='font-size:12.0pt;font-family:宋体'>标记<span lang=EN-US>-</span>整理（<span
  lang=EN-US>Mark-Compact</span>）：在标记<span lang=EN-US>-</span>清除的基础上，增加整理过程，使存活对象尽可能紧凑地排列，减少空间碎片。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>3.
  </span><span style='font-size:12.0pt;font-family:宋体'>复制（<span lang=EN-US>Copying</span>）：将内存划分为两个相等的部分，每次只使用其中一个，在垃圾回收时，将存活对象复制到未使用的部分，然后清空旧的内存区域。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>类加载的过程主要包括以下几个阶段：</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>1.
  </span><span style='font-size:12.0pt;font-family:宋体'>加载（<span lang=EN-US>Loading</span>）：找到对应的字节码文件，并生成一个<span
  lang=EN-US> Class </span>对象。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>2.
  </span><span style='font-size:12.0pt;font-family:宋体'>验证（<span lang=EN-US>Verification</span>）：确保加载的类信息符合<span
  lang=EN-US> JVM </span>规范。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>3.
  </span><span style='font-size:12.0pt;font-family:宋体'>准备（<span lang=EN-US>Preparation</span>）：为类中的静态字段分配内存，并设置默认初始值。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>4.
  </span><span style='font-size:12.0pt;font-family:宋体'>解析（<span lang=EN-US>Resolution</span>）：将符号引用替换为直接引用。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>5.
  </span><span style='font-size:12.0pt;font-family:宋体'>初始化（<span lang=EN-US>Initialization</span>）：执行类的初始化代码，为静态字段赋予正确的初始值。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>数据库<span
  lang=EN-US>SQL</span>和<span lang=EN-US>NoSQL</span>的区别主要体现在以下几个方面：</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>1.
  </span><span style='font-size:12.0pt;font-family:宋体'>数据模型：<span lang=EN-US>SQL</span>数据库通常是关系型数据库，采用表格模型，数据以行和列的形式组织，表与表之间通过外键关联。而<span
  lang=EN-US>NoSQL</span>数据库包括键值对存储、文档存储、列存储和图形数据库等多种类型，适用于非结构化或半结构化数据。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>2.
  </span><span style='font-size:12.0pt;font-family:宋体'>查询语言：<span lang=EN-US>SQL</span>数据库使用标准化的<span
  lang=EN-US>SQL</span>查询语言进行数据查询和操作。<span lang=EN-US>NoSQL</span>数据库通常没有统一的查询语言，而是通过<span
  lang=EN-US>API</span>进行数据操作。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>3.
  </span><span style='font-size:12.0pt;font-family:宋体'>事务处理：<span lang=EN-US>SQL</span>数据库通常支持<span
  lang=EN-US>ACID</span>属性的事务处理，保证数据的一致性和完整性。<span lang=EN-US>NoSQL</span>数据库在事务处理上可能有所简化，某些可能只支持较弱的一致性模型，更注重性能和可扩展性。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>4.
  </span><span style='font-size:12.0pt;font-family:宋体'>可扩展性：<span lang=EN-US>NoSQL</span>数据库通常设计为分布式系统，易于水平扩展，通过增加服务器节点来提高性能。而<span
  lang=EN-US>SQL</span>数据库垂直扩展较为常见，通过提高单个服务器的能力来提升性能。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>5.
  </span><span style='font-size:12.0pt;font-family:宋体'>使用场景：<span lang=EN-US>SQL</span>数据库适用于需要强数据一致性和复杂查询的场景，如金融服务和电子商务。<span
  lang=EN-US>NoSQL</span>数据库适用于大数据和高流量应用，如社交网络和实时分析。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>事务的<span
  lang=EN-US>ACID</span>属性指的是：</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>-
  </span><span style='font-size:12.0pt;font-family:宋体'>原子性（<span lang=EN-US>Atomicity</span>）：事务中的所有操作要么全部成功执行，要么全部失败并回滚，不会留下中间状态。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>-
  </span><span style='font-size:12.0pt;font-family:宋体'>一致性（<span lang=EN-US>Consistency</span>）：事务必须使数据库从一个一致性状态转移到另一个一致性状态，不会破坏数据的完整性约束。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>-
  </span><span style='font-size:12.0pt;font-family:宋体'>隔离性（<span lang=EN-US>Isolation</span>）：并发执行的事务彼此隔离，不会互相干扰，每个事务都像是在独立的环境中执行。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>-
  </span><span style='font-size:12.0pt;font-family:宋体'>持久性（<span lang=EN-US>Durability</span>）：一旦事务提交，对数据库的更改就是永久性的，即便发生系统故障也不会丢失。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>Spring
  </span><span style='font-size:12.0pt;font-family:宋体'>框架的核心模块包括：</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>1.
  Spring Core</span><span style='font-size:12.0pt;font-family:宋体'>：提供了<span
  lang=EN-US>Spring</span>框架的核心功能，包括依赖注入（<span lang=EN-US>DI</span>）、控制反转（<span
  lang=EN-US>IoC</span>）和面向切面编程（<span lang=EN-US>AOP</span>）。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>2.
  Spring Context</span><span style='font-size:12.0pt;font-family:宋体'>：提供了一种访问对象的方式，如<span
  lang=EN-US>JNDI</span>，用于实现数据访问和事务管理等。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>3.
  Spring Data Access/Integration</span><span style='font-size:12.0pt;
  font-family:宋体'>：包含了对<span lang=EN-US>JDBC</span>数据访问的支持以及对<span lang=EN-US>JMS</span>、<span
  lang=EN-US>Hibernate</span>等的集成。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>4.
  Spring Web</span><span style='font-size:12.0pt;font-family:宋体'>：提供了创建<span
  lang=EN-US>Web</span>应用程序的全面支持，包括多部分文件上传功能和初始化<span lang=EN-US>IoC</span>容器的<span
  lang=EN-US>Web</span>相关功能。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>5.
  Spring MVC</span><span style='font-size:12.0pt;font-family:宋体'>：为创建基于<span
  lang=EN-US>Servlet</span>的<span lang=EN-US>Spring</span>应用程序提供了<span
  lang=EN-US>MVC</span>（<span lang=EN-US>Model-View-Controller</span>）模式的实现。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>6.
  Spring Test</span><span style='font-size:12.0pt;font-family:宋体'>：提供了对<span
  lang=EN-US>Spring</span>组件进行单元测试和集成测试的支持。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>Spring
  AOP</span><span style='font-size:12.0pt;font-family:宋体'>（<span lang=EN-US>Aspect-Oriented
  Programming</span>，面向切面编程）是<span lang=EN-US>Spring</span>框架的一个关键组成部分，它允许你将横切关注点（如日志、安全、事务管理等）与业务逻辑分离。<span
  lang=EN-US>Spring AOP</span>模块通过动态代理实现横切关注点的织入。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>Spring
  AOP</span><span style='font-size:12.0pt;font-family:宋体'>的工作原理如下：</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>1.
  **</span><span style='font-size:12.0pt;font-family:宋体'>定义切面（<span lang=EN-US>Aspect</span>）<span
  lang=EN-US>**</span>：切面是一个包含多个通知（<span lang=EN-US>Advice</span>）的定义，这些通知将在特定<span
  lang=EN-US> Join Points</span>（连接点，通常是方法的执行点）被触发。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>2.
  **</span><span style='font-size:12.0pt;font-family:宋体'>定义通知（<span lang=EN-US>Advice</span>）<span
  lang=EN-US>**</span>：通知描述了在切面的某个特定连接点应该执行的逻辑，比如<span lang=EN-US>“</span>前置通知<span
  lang=EN-US>”</span>、<span lang=EN-US>“</span>后置通知<span lang=EN-US>”</span>、<span
  lang=EN-US>“</span>异常通知<span lang=EN-US>”</span>和<span lang=EN-US>“</span>环绕通知<span
  lang=EN-US>”</span>。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>3.
  **</span><span style='font-size:12.0pt;font-family:宋体'>定义切点（<span lang=EN-US>Pointcut</span>）<span
  lang=EN-US>**</span>：切点是用于匹配连接点的表达式，它决定了哪些方法会被<span lang=EN-US>AOP</span>系统拦截。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>4.
  **</span><span style='font-size:12.0pt;font-family:宋体'>代理对象创建<span
  lang=EN-US>**</span>：<span lang=EN-US>Spring AOP</span>创建一个代理对象，这个代理对象会拦截定义好的切点对应的方法调用，并在方法执行前后插入通知逻辑。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>5.
  **</span><span style='font-size:12.0pt;font-family:宋体'>织入（<span lang=EN-US>Weaving</span>）<span
  lang=EN-US>**</span>：织入是将切面应用到目标对象并创建代理对象的过程，这个过程中，<span lang=EN-US>AOP</span>框架会在运行时将通知逻辑织入到代理对象的方法执行中。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>Spring
  AOP</span><span style='font-size:12.0pt;font-family:宋体'>通过这种方式，允许开发者在不修改源代码的情况下，增加或修改系统的行为。这是通过动态代理（基于<span
  lang=EN-US>Java</span>的反射机制）或者字节码操作（如使用<span lang=EN-US>AspectJ</span>的编译时织入）实现的。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>单例模式（<span
  lang=EN-US>Singleton</span>）：</span></p>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>设计思路：单例模式确保一个类只有一个实例，并提供一个全局访问点来获取这个实例。它通常涉及到一个静态成员变量和一个静态方法，这个静态方法负责创建类实例，并在创建后返回这个实例的引用。</span></p>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>适用场景：当系统中需要一个类来控制资源的访问，确保资源不被重复创建时，如数据库连接池、线程池、配置对象等。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>工厂模式（<span
  lang=EN-US>Factory</span>）：</span></p>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>设计思路：工厂模式定义了一个接口用于创建对象，但让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类中进行。</span></p>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>适用场景：当需要创建一系列相关或相互依赖对象的类时，且这些对象的具体类型在创建时可以延迟确定时，如日志记录器、数据库连接等。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>观察者模式（<span
  lang=EN-US>Observer</span>）：</span></p>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>设计思路：观察者模式定义了对象之间的一对多依赖关系，当一个对象改变状态时，所有依赖于它的对象都会得到通知并自动更新。</span></p>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>适用场景：当有一个对象（目标）的状态改变需要通知到一组对象（观察者）时，如事件订阅、股票价格更新通知等场景。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>1.
  JDBC</span><span style='font-size:12.0pt;font-family:宋体'>数据库连接管理通常涉及以下步骤：</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;&nbsp;
  - </span><span style='font-size:12.0pt;font-family:宋体'>加载数据库驱动：通过反射机制加载数据库驱动类的字节码，例如<span
  lang=EN-US>`Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;)`</span>。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;&nbsp;
  - </span><span style='font-size:12.0pt;font-family:宋体'>建立连接：使用<span
  lang=EN-US>`DriverManager.getConnection(url, user, password)`</span>来获取数据库连接。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;&nbsp;
  - </span><span style='font-size:12.0pt;font-family:宋体'>管理连接池：使用连接池（如<span
  lang=EN-US>Apache DBCP, HikariCP</span>）来复用数据库连接，减少连接创建和销毁的开销。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;&nbsp;
  - </span><span style='font-size:12.0pt;font-family:宋体'>关闭连接：在完成数据库操作后，应关闭<span
  lang=EN-US>`ResultSet`</span>、<span lang=EN-US>`Statement`</span>和<span
  lang=EN-US>`Connection`</span>对象来释放数据库资源。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>2.
  </span><span style='font-size:12.0pt;font-family:宋体'>优化<span lang=EN-US>SQL</span>查询性能的方法：</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;&nbsp;
  - </span><span style='font-size:12.0pt;font-family:宋体'>选择合适的索引：为数据库表中经常查询的列创建索引。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;&nbsp;
  - </span><span style='font-size:12.0pt;font-family:宋体'>减少数据传输：只查询需要的列，避免使用<span
  lang=EN-US>`SELECT *`</span>。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;&nbsp;
  - </span><span style='font-size:12.0pt;font-family:宋体'>使用预编译的<span
  lang=EN-US>`PreparedStatement`</span>：提高<span lang=EN-US>SQL</span>执行效率，减少<span
  lang=EN-US>SQL</span>解析时间。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;&nbsp;
  - </span><span style='font-size:12.0pt;font-family:宋体'>批量处理：使用<span
  lang=EN-US>`Batch Update`</span>进行批量插入、更新或删除操作，减少网络往返次数。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;&nbsp;
  - </span><span style='font-size:12.0pt;font-family:宋体'>避免复杂的<span lang=EN-US>SQL</span>：尽量简化<span
  lang=EN-US>SQL</span>语句，避免使用复杂的子查询和多重嵌套。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>3.
  </span><span style='font-size:12.0pt;font-family:宋体'>针对大数据量的操作，以下策略可以避免内存溢出：</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;&nbsp;
  - </span><span style='font-size:12.0pt;font-family:宋体'>分批查询：将大量数据分批次处理，每次只处理一小部分数据。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;&nbsp;
  - </span><span style='font-size:12.0pt;font-family:宋体'>流式查询：使用游标（<span
  lang=EN-US>Cursor</span>）逐行处理数据，避免一次性加载所有数据到内存中。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;&nbsp;
  - </span><span style='font-size:12.0pt;font-family:宋体'>限制结果集大小：通过设置<span
  lang=EN-US>`Statement`</span>的<span lang=EN-US>`setFetchSize`</span>方法来限制每次从数据库检索的行数。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;&nbsp;
  - </span><span style='font-size:12.0pt;font-family:宋体'>内存监控与清理：定期检查<span
  lang=EN-US>JVM</span>内存使用情况，及时释放不再使用的对象。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>Spring
  Boot</span><span style='font-size:12.0pt;font-family:宋体'>的优势包括：</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>-
  </span><span style='font-size:12.0pt;font-family:宋体'>快速开发：<span lang=EN-US>Spring
  Boot</span>能够简化<span lang=EN-US>Spring</span>应用的初始搭建以及开发过程，提供默认配置，减少手动配置。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>-
  </span><span style='font-size:12.0pt;font-family:宋体'>独立运行：可以创建一个包含<span
  lang=EN-US>Tomcat, Jetty</span>或<span lang=EN-US>Undertow</span>的独立运行<span
  lang=EN-US>Jar</span>包，简化了部署过程。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>-
  </span><span style='font-size:12.0pt;font-family:宋体'>无代码生成和<span lang=EN-US>XML</span>配置：不需要代码生成器，也不需要<span
  lang=EN-US>XML</span>配置文件，使用注解配置即可。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>-
  </span><span style='font-size:12.0pt;font-family:宋体'>提供生产级特性：比如指标、健康检查和外部化配置。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>-
  </span><span style='font-size:12.0pt;font-family:宋体'>微服务支持：<span lang=EN-US>Spring
  Boot</span>与<span lang=EN-US>Spring Cloud</span>结合，非常适合微服务架构的开发。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>MyBatis</span><span
  style='font-size:12.0pt;font-family:宋体'>中的一对多或多对多关系映射通常通过以下方式处理：</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>-
  </span><span style='font-size:12.0pt;font-family:宋体'>使用<span lang=EN-US>`&lt;resultMap&gt;`</span>标签定义结果映射，通过<span
  lang=EN-US>`collection`</span>元素来处理一对多关系，通过嵌套的<span lang=EN-US>`select`</span>查询或嵌套的<span
  lang=EN-US>`resultMap`</span>来加载子对象。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>-
  </span><span style='font-size:12.0pt;font-family:宋体'>对于多对多关系，可以创建一个中间表来表示两个表之间的关系，并在<span
  lang=EN-US>`&lt;resultMap&gt;`</span>中使用两个<span lang=EN-US>`collection`</span>元素分别引用两个关联的表。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>-
  </span><span style='font-size:12.0pt;font-family:宋体'>也可以使用<span lang=EN-US>MyBatis</span>的<span
  lang=EN-US>`@Many`</span>注解在接口方法中指明多对多或一对多的关系映射。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <ol style='margin-top:0cm' start=1 type=1>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>读写锁（<span
       lang=EN-US>ReadWriteLock</span>）：实现了<span lang=EN-US>ReadWriteLock</span>接口，分为读锁（共享锁）和写锁（排他锁）。读锁允许多个线程同时读取，写锁则只允许一个线程写入。适用于读多写少的场景。</span></li>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>乐观锁（<span
       lang=EN-US>Optimistic Locking</span>）：通常通过<span lang=EN-US>CAS</span>（<span
       lang=EN-US>Compare And Swap</span>）算法实现，适用于冲突发生概率较低的场景。它不是通过阻塞来防止并发冲突，而是在更新数据时检查是否有其他线程同时修改了数据。</span></li>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>悲观锁（<span
       lang=EN-US>Pessimistic Locking</span>）：适用于写操作频繁，冲突概率较高的场景。它通过阻塞其他线程直到锁被释放来防止并发冲突。</span></li>
  </ol>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>微服务架构是一种将大型应用程序分解为多个独立、模块化服务的设计方法。每个服务都是围绕特定业务功能构建的，并且可以独立部署和扩展。这些服务通过定义良好的<span
  lang=EN-US>API</span>进行通信，通常使用轻量级的通信机制，如<span lang=EN-US>HTTP RESTful API</span>。微服务架构旨在提高大型应用程序的可维护性、可扩展性和灵活性，允许快速、频繁地交付大型、复杂的应用程序。与传统的单体架构相比，微服务架构能够更好地适应现代云计算环境，实现自动化部署和持续集成。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>微服务架构的优点包括：</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>1.
  </span><span style='font-size:12.0pt;font-family:宋体'>开发简单：每个服务只关注一个业务功能，代码较少且易于理解。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>2.
  </span><span style='font-size:12.0pt;font-family:宋体'>易于局部修改：服务可以独立测试、部署、升级和发布，修改某个服务时只需重新部署该服务。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>3.
  </span><span style='font-size:12.0pt;font-family:宋体'>容错性高：每个服务独立部署，单个服务的故障不会影响整个系统。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>4.
  </span><span style='font-size:12.0pt;font-family:宋体'>灵活性和可扩展性：可以根据需求独立扩展服务，提高系统整体性能。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>5.
  </span><span style='font-size:12.0pt;font-family:宋体'>技术多样性：不同服务可以选择最适合其需求的技术栈。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>挑战包括：</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>1.
  </span><span style='font-size:12.0pt;font-family:宋体'>复杂性：微服务架构作为分布式系统，比单体应用更复杂且难以管理。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>2.
  </span><span style='font-size:12.0pt;font-family:宋体'>故障诊断难：分布式部署的跟踪和故障诊断比单体架构复杂。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>3.
  </span><span style='font-size:12.0pt;font-family:宋体'>数据一致性：每个服务拥有自己的数据库，保持数据一致性是一大挑战。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>4.
  </span><span style='font-size:12.0pt;font-family:宋体'>成本高：更多的服务意味着更高的运维投入和管理成本。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>服务发现通常通过以下方式实现：</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>1.
  </span><span style='font-size:12.0pt;font-family:宋体'>服务注册与发现机制：如<span
  lang=EN-US>Eureka</span>、<span lang=EN-US>Consul</span>或<span lang=EN-US>Zookeeper</span>，服务实例在启动时向注册中心注册，并定期发送心跳以证明其存活状态。其他服务通过查询注册中心来发现依赖的服务。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>2.
  API</span><span style='font-size:12.0pt;font-family:宋体'>网关：作为系统的入口点，负责路由请求到相应的服务实例。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>服务间通信可以通过以下方式进行：</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>1.
  HTTP RESTful API</span><span style='font-size:12.0pt;font-family:宋体'>：服务之间通过轻量级的<span
  lang=EN-US>HTTP</span>请求进行通信，通常使用<span lang=EN-US>JSON</span>或<span
  lang=EN-US>XML</span>作为数据交换格式。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>2.
  </span><span style='font-size:12.0pt;font-family:宋体'>消息队列：如<span lang=EN-US>RabbitMQ</span>、<span
  lang=EN-US>Kafka</span>等，服务通过发送消息到队列进行异步通信。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>在分布式系统中，保证数据的一致性和可用性可以采取以下措施：</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>1.
  </span><span style='font-size:12.0pt;font-family:宋体'>分布式事务：通过将多个操作打包成原子性操作来保证一致性，如使用<span
  lang=EN-US>TCC</span>、<span lang=EN-US>XA</span>等事务管理器。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>2.
  </span><span style='font-size:12.0pt;font-family:宋体'>数据同步机制：通过定时同步或事件驱动的数据同步来确保数据一致性。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>3.
  </span><span style='font-size:12.0pt;font-family:宋体'>最终一致性模型：允许系统在一段时间内数据不一致，最终达到一致性。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>4.
  </span><span style='font-size:12.0pt;font-family:宋体'>数据备份和冗余存储：提高数据的可用性和容错性，确保在部分服务故障时数据不会丢失。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>5.
  </span><span style='font-size:12.0pt;font-family:宋体'>故障转移和自动恢复机制：当服务不可用时，自动切换到备份服务，确保系统的持续可用性。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>1.
  </span><span style='font-size:12.0pt;font-family:宋体'>防止常见的安全攻击：</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;&nbsp;
  - SQL</span><span style='font-size:12.0pt;font-family:宋体'>注入：使用参数化查询（也称为预处理语句）来防止<span
  lang=EN-US>SQL</span>注入。这意味着不要将用户输入直接拼接到<span lang=EN-US>SQL</span>语句中，而是使用数据库引擎提供的参数化接口。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;&nbsp;
  - XSS</span><span style='font-size:12.0pt;font-family:宋体'>（跨站脚本攻击）：对用户输入进行适当的转义和验证，确保输出的内容被正确地编码。可以使用内容安全策略（<span
  lang=EN-US>CSP</span>）来限制页面上可以执行的脚本。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>2.
  </span><span style='font-size:12.0pt;font-family:宋体'>使用<span lang=EN-US>JWT</span>（<span
  lang=EN-US>JSON Web Tokens</span>）进行身份验证的工作流程：</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;&nbsp;
  - </span><span style='font-size:12.0pt;font-family:宋体'>用户登录：用户向服务器发送登录信息（如用户名和密码）。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;&nbsp;
  - </span><span style='font-size:12.0pt;font-family:宋体'>验证：服务器验证用户身份信息，如果验证成功，则创建一个<span
  lang=EN-US>JWT</span>。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;&nbsp;
  - </span><span style='font-size:12.0pt;font-family:宋体'>创建<span lang=EN-US>JWT</span>：服务器在<span
  lang=EN-US>JWT</span>中包含用户的一些基本信息（如用户<span lang=EN-US>ID</span>、角色等），并使用密钥对其进行签名。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;&nbsp;
  - </span><span style='font-size:12.0pt;font-family:宋体'>发送<span lang=EN-US>JWT</span>：服务器将生成的<span
  lang=EN-US>JWT</span>发送给客户端。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;&nbsp;
  - </span><span style='font-size:12.0pt;font-family:宋体'>存储<span lang=EN-US>JWT</span>：客户端将<span
  lang=EN-US>JWT</span>存储在<span lang=EN-US>localStorage</span>或<span
  lang=EN-US>sessionStorage</span>中，或设置在<span lang=EN-US>HTTP Cookie</span>中。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;&nbsp;
  - </span><span style='font-size:12.0pt;font-family:宋体'>发送请求：客户端在随后的请求中，将<span
  lang=EN-US>JWT</span>作为认证信息发送给服务器（通常放在<span lang=EN-US>HTTP</span>请求的<span
  lang=EN-US>Authorization</span>头部，格式为<span lang=EN-US>`Bearer &lt;token&gt;`</span>）。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;&nbsp;
  - </span><span style='font-size:12.0pt;font-family:宋体'>验证<span lang=EN-US>JWT</span>：服务器验证<span
  lang=EN-US>JWT</span>的签名和有效性，如果验证通过，则处理请求，否则拒绝请求。</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>Spring
  </span><span style='font-size:12.0pt;font-family:宋体'>和<span lang=EN-US>
  Spring Boot </span>是<span lang=EN-US> Java </span>开发中广泛使用的两个框架，它们密切相关但又有显著区别。以下是对它们的详细解释和对比：</span></p>
  <div class=MsoNormal align=left style='text-align:left'><span lang=EN-US
  style='font-size:12.0pt;font-family:宋体'>
  <hr size=1 width="100%" noshade style='color:black' align=left>
  </span></div>
  <p class=MsoNormal><b><span lang=EN-US style='font-size:12.0pt;font-family:
  宋体'>1. Spring Framework</span></b></p>
  <p class=MsoNormal><b><span style='font-size:12.0pt;font-family:宋体'>定义</span></b></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>Spring
  </span><span style='font-size:12.0pt;font-family:宋体'>是一个开源的<span lang=EN-US>&nbsp;</span><b>轻量级<span
  lang=EN-US> Java </span>开发框架</b>，最初由<span lang=EN-US> Rod Johnson </span>于<span
  lang=EN-US> 2003 </span>年提出，旨在简化企业级<span lang=EN-US> Java </span>应用的开发。它通过<span
  lang=EN-US>&nbsp;</span><b>依赖注入（<span lang=EN-US>DI</span>）</b><span
  lang=EN-US>&nbsp;</span>和<span lang=EN-US>&nbsp;</span><b>面向切面编程（<span
  lang=EN-US>AOP</span>）</b><span lang=EN-US>&nbsp;</span>等核心特性，提供模块化的解决方案。</span></p>
  <p class=MsoNormal><b><span style='font-size:12.0pt;font-family:宋体'>核心特性</span></b></p>
  <ol style='margin-top:0cm' start=1 type=1>
   <li class=MsoNormal><b><span style='font-size:12.0pt;font-family:宋体'>控制反转（<span
       lang=EN-US>IoC</span>）</span></b></li>
   <ul style='margin-top:0cm' type=disc>
    <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>通过容器管理对象的生命周期和依赖关系，开发者无需手动创建对象。</span></li>
    <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>依赖注入（<span
        lang=EN-US>DI</span>）是实现<span lang=EN-US> IoC </span>的主要方式，支持构造器注入、<span
        lang=EN-US>Setter </span>注入等。</span></li>
   </ul>
   <li class=MsoNormal><b><span style='font-size:12.0pt;font-family:宋体'>面向切面编程（<span
       lang=EN-US>AOP</span>）</span></b></li>
   <ul style='margin-top:0cm' type=disc>
    <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>将横切关注点（如日志、事务、安全）与业务逻辑分离，通过切面（<span
        lang=EN-US>Aspect</span>）统一管理。</span></li>
   </ul>
   <li class=MsoNormal><b><span style='font-size:12.0pt;font-family:宋体'>模块化设计</span></b></li>
   <ul style='margin-top:0cm' type=disc>
    <li class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:
        宋体'>Spring </span><span style='font-size:12.0pt;font-family:宋体'>由多个模块组成，可按需选择：</span></li>
    <ul style='margin-top:0cm' type=square>
     <li class=MsoNormal><b><span lang=EN-US style='font-size:12.0pt;
         font-family:宋体'>Core Container</span></b><span style='font-size:12.0pt;
         font-family:宋体'>（核心容器）</span></li>
     <li class=MsoNormal><b><span lang=EN-US style='font-size:12.0pt;
         font-family:宋体'>Data Access</span></b><span style='font-size:12.0pt;
         font-family:宋体'>（<span lang=EN-US>JDBC</span>、<span lang=EN-US>ORM </span>支持）</span></li>
     <li class=MsoNormal><b><span lang=EN-US style='font-size:12.0pt;
         font-family:宋体'>Web MVC</span></b><span style='font-size:12.0pt;
         font-family:宋体'>（<span lang=EN-US>Web </span>开发）</span></li>
     <li class=MsoNormal><b><span lang=EN-US style='font-size:12.0pt;
         font-family:宋体'>Security</span></b><span style='font-size:12.0pt;
         font-family:宋体'>（安全）</span></li>
     <li class=MsoNormal><b><span lang=EN-US style='font-size:12.0pt;
         font-family:宋体'>Testing</span></b><span style='font-size:12.0pt;
         font-family:宋体'>（测试支持）等。</span></li>
    </ul>
   </ul>
   <li class=MsoNormal><b><span style='font-size:12.0pt;font-family:宋体'>事务管理</span></b></li>
   <ul style='margin-top:0cm' type=disc>
    <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>提供声明式事务管理，通过注解或<span
        lang=EN-US> XML </span>配置简化事务控制。</span></li>
   </ul>
  </ol>
  <p class=MsoNormal><b><span style='font-size:12.0pt;font-family:宋体'>典型使用场景</span></b></p>
  <ul style='margin-top:0cm' type=disc>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>需要高度定制化的企业级应用。</span></li>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>复杂的多层架构系统（如银行、电商平台）。</span></li>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>需要精细控制依赖关系和配置的场景。</span></li>
  </ul>
  <p class=MsoNormal><b><span style='font-size:12.0pt;font-family:宋体'>缺点</span></b></p>
  <ul style='margin-top:0cm' type=disc>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>配置繁琐（<span
       lang=EN-US>XML </span>或<span lang=EN-US> Java </span>配置）。</span></li>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>需要手动集成第三方库和工具。</span></li>
  </ul>
  <div class=MsoNormal align=left style='text-align:left'><span lang=EN-US
  style='font-size:12.0pt;font-family:宋体'>
  <hr size=1 width="100%" noshade style='color:black' align=left>
  </span></div>
  <p class=MsoNormal><b><span lang=EN-US style='font-size:12.0pt;font-family:
  宋体'>2. Spring Boot</span></b></p>
  <p class=MsoNormal><b><span style='font-size:12.0pt;font-family:宋体'>定义</span></b></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>Spring
  Boot </span><span style='font-size:12.0pt;font-family:宋体'>是<span lang=EN-US>
  Spring </span>的<span lang=EN-US>&nbsp;</span><b>扩展框架</b>，于<span lang=EN-US>
  2014 </span>年推出，目标是简化<span lang=EN-US> Spring </span>应用的初始搭建和开发过程。它通过约定大于配置的原则，提供开箱即用的体验。</span></p>
  <p class=MsoNormal><b><span style='font-size:12.0pt;font-family:宋体'>核心特性</span></b></p>
  <ol style='margin-top:0cm' start=1 type=1>
   <li class=MsoNormal><b><span style='font-size:12.0pt;font-family:宋体'>自动配置（<span
       lang=EN-US>Auto-Configuration</span>）</span></b></li>
   <ul style='margin-top:0cm' type=disc>
    <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>根据项目依赖的<span
        lang=EN-US> JAR </span>包（如<span lang=EN-US>&nbsp;spring-boot-starter-web</span>）自动配置<span
        lang=EN-US> Spring </span>应用。</span></li>
    <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>例如：引入<span
        lang=EN-US>&nbsp;spring-boot-starter-data-jpa&nbsp;</span>后，自动配置数据源和<span
        lang=EN-US> Hibernate</span>。</span></li>
   </ul>
   <li class=MsoNormal><b><span style='font-size:12.0pt;font-family:宋体'>起步依赖（<span
       lang=EN-US>Starter Dependencies</span>）</span></b></li>
   <ul style='margin-top:0cm' type=disc>
    <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>预定义的依赖包（如<span
        lang=EN-US>&nbsp;spring-boot-starter-web&nbsp;</span>包含<span
        lang=EN-US> Tomcat</span>、<span lang=EN-US>Spring MVC</span>、<span
        lang=EN-US>Jackson </span>等），避免手动管理依赖版本。</span></li>
   </ul>
   <li class=MsoNormal><b><span style='font-size:12.0pt;font-family:宋体'>内嵌服务器（<span
       lang=EN-US>Embedded Server</span>）</span></b></li>
   <ul style='margin-top:0cm' type=disc>
    <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>默认内嵌<span
        lang=EN-US> Tomcat</span>、<span lang=EN-US>Jetty </span>或<span
        lang=EN-US> Undertow</span>，无需部署<span lang=EN-US> WAR </span>文件到外部服务器。</span></li>
   </ul>
   <li class=MsoNormal><b><span lang=EN-US style='font-size:12.0pt;font-family:
       宋体'>Actuator</span></b><b><span style='font-size:12.0pt;font-family:
       宋体'>（监控与管理）</span></b></li>
   <ul style='margin-top:0cm' type=disc>
    <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>提供生产级监控端点（如健康检查、性能指标）。</span></li>
   </ul>
   <li class=MsoNormal><b><span style='font-size:12.0pt;font-family:宋体'>简化配置</span></b></li>
   <ul style='margin-top:0cm' type=disc>
    <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>使用<span
        lang=EN-US>&nbsp;application.properties&nbsp;</span>或<span lang=EN-US>&nbsp;application.yml&nbsp;</span>文件统一管理配置。</span></li>
    <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>支持多环境配置（开发、测试、生产）。</span></li>
   </ul>
  </ol>
  <p class=MsoNormal><b><span style='font-size:12.0pt;font-family:宋体'>典型使用场景</span></b></p>
  <ul style='margin-top:0cm' type=disc>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>快速构建微服务或<span
       lang=EN-US> RESTful API</span>。</span></li>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>需要快速原型开发的项目。</span></li>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>希望减少样板代码和配置的场景。</span></li>
  </ul>
  <p class=MsoNormal><b><span style='font-size:12.0pt;font-family:宋体'>缺点</span></b></p>
  <ul style='margin-top:0cm' type=disc>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>对高度定制化需求的支持不如原生<span
       lang=EN-US> Spring </span>灵活。</span></li>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>自动配置可能导致<span
       lang=EN-US>“</span>黑盒<span lang=EN-US>”</span>问题，需要理解其原理才能调试。</span></li>
  </ul>
  <div class=MsoNormal align=left style='text-align:left'><span lang=EN-US
  style='font-size:12.0pt;font-family:宋体'>
  <hr size=1 width="100%" noshade style='color:black' align=left>
  </span></div>
  <p class=MsoNormal><b><span lang=EN-US style='font-size:12.0pt;font-family:
  宋体'>3. Spring </span></b><b><span style='font-size:12.0pt;font-family:宋体'>与<span
  lang=EN-US> Spring Boot </span>的关键区别</span></b></p>
  <table class=MsoNormalTable border=0 cellspacing=0 cellpadding=0
   style='background:white;border-collapse:collapse'>
   <thead>
    <tr>
     <td style='border:solid #CCCCCC 1.0pt;background:#F0F0F0;padding:3.75pt 7.5pt 3.75pt 7.5pt'>
     <p class=MsoNormal><b><span style='font-size:12.0pt;font-family:宋体;
     color:black'>特性</span></b></p>
     </td>
     <td style='border:solid #CCCCCC 1.0pt;border-left:none;background:#F0F0F0;
     padding:3.75pt 7.5pt 3.75pt 7.5pt'>
     <p class=MsoNormal><b><span lang=EN-US style='font-size:12.0pt;font-family:
     宋体;color:black'>Spring</span></b></p>
     </td>
     <td style='border:solid #CCCCCC 1.0pt;border-left:none;background:#F0F0F0;
     padding:3.75pt 7.5pt 3.75pt 7.5pt'>
     <p class=MsoNormal><b><span lang=EN-US style='font-size:12.0pt;font-family:
     宋体;color:black'>Spring Boot</span></b></p>
     </td>
    </tr>
   </thead>
   <tr>
    <td style='border:solid #CCCCCC 1.0pt;border-top:none;padding:3.75pt 7.5pt 3.75pt 7.5pt'>
    <p class=MsoNormal><b><span style='font-size:12.0pt;font-family:宋体;
    color:black'>配置方式</span></b></p>
    </td>
    <td style='border-top:none;border-left:none;border-bottom:solid #CCCCCC 1.0pt;
    border-right:solid #CCCCCC 1.0pt;padding:3.75pt 7.5pt 3.75pt 7.5pt'>
    <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体;color:black'>需手动配置<span
    lang=EN-US> XML </span>或<span lang=EN-US> Java Config</span></span></p>
    </td>
    <td style='border-top:none;border-left:none;border-bottom:solid #CCCCCC 1.0pt;
    border-right:solid #CCCCCC 1.0pt;padding:3.75pt 7.5pt 3.75pt 7.5pt'>
    <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体;color:black'>自动配置，支持零配置启动</span></p>
    </td>
   </tr>
   <tr>
    <td style='border:solid #CCCCCC 1.0pt;border-top:none;background:#F8F8F8;
    padding:3.75pt 7.5pt 3.75pt 7.5pt'>
    <p class=MsoNormal><b><span style='font-size:12.0pt;font-family:宋体;
    color:black'>依赖管理</span></b></p>
    </td>
    <td style='border-top:none;border-left:none;border-bottom:solid #CCCCCC 1.0pt;
    border-right:solid #CCCCCC 1.0pt;background:#F8F8F8;padding:3.75pt 7.5pt 3.75pt 7.5pt'>
    <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体;color:black'>需手动管理依赖版本</span></p>
    </td>
    <td style='border-top:none;border-left:none;border-bottom:solid #CCCCCC 1.0pt;
    border-right:solid #CCCCCC 1.0pt;background:#F8F8F8;padding:3.75pt 7.5pt 3.75pt 7.5pt'>
    <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体;color:black'>通过<span
    lang=EN-US> Starter </span>依赖自动管理</span></p>
    </td>
   </tr>
   <tr>
    <td style='border:solid #CCCCCC 1.0pt;border-top:none;padding:3.75pt 7.5pt 3.75pt 7.5pt'>
    <p class=MsoNormal><b><span style='font-size:12.0pt;font-family:宋体;
    color:black'>内嵌服务器</span></b></p>
    </td>
    <td style='border-top:none;border-left:none;border-bottom:solid #CCCCCC 1.0pt;
    border-right:solid #CCCCCC 1.0pt;padding:3.75pt 7.5pt 3.75pt 7.5pt'>
    <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体;color:black'>需外部服务器（如<span
    lang=EN-US> Tomcat</span>）</span></p>
    </td>
    <td style='border-top:none;border-left:none;border-bottom:solid #CCCCCC 1.0pt;
    border-right:solid #CCCCCC 1.0pt;padding:3.75pt 7.5pt 3.75pt 7.5pt'>
    <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体;color:black'>默认内嵌<span
    lang=EN-US> Tomcat/Jetty</span></span></p>
    </td>
   </tr>
   <tr>
    <td style='border:solid #CCCCCC 1.0pt;border-top:none;background:#F8F8F8;
    padding:3.75pt 7.5pt 3.75pt 7.5pt'>
    <p class=MsoNormal><b><span style='font-size:12.0pt;font-family:宋体;
    color:black'>部署方式</span></b></p>
    </td>
    <td style='border-top:none;border-left:none;border-bottom:solid #CCCCCC 1.0pt;
    border-right:solid #CCCCCC 1.0pt;background:#F8F8F8;padding:3.75pt 7.5pt 3.75pt 7.5pt'>
    <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体;color:black'>打包为<span
    lang=EN-US> WAR </span>部署到服务器</span></p>
    </td>
    <td style='border-top:none;border-left:none;border-bottom:solid #CCCCCC 1.0pt;
    border-right:solid #CCCCCC 1.0pt;background:#F8F8F8;padding:3.75pt 7.5pt 3.75pt 7.5pt'>
    <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体;color:black'>打包为独立<span
    lang=EN-US> JAR</span>，直接运行</span></p>
    </td>
   </tr>
   <tr>
    <td style='border:solid #CCCCCC 1.0pt;border-top:none;padding:3.75pt 7.5pt 3.75pt 7.5pt'>
    <p class=MsoNormal><b><span style='font-size:12.0pt;font-family:宋体;
    color:black'>适用场景</span></b></p>
    </td>
    <td style='border-top:none;border-left:none;border-bottom:solid #CCCCCC 1.0pt;
    border-right:solid #CCCCCC 1.0pt;padding:3.75pt 7.5pt 3.75pt 7.5pt'>
    <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体;color:black'>复杂、高度定制化的企业应用</span></p>
    </td>
    <td style='border-top:none;border-left:none;border-bottom:solid #CCCCCC 1.0pt;
    border-right:solid #CCCCCC 1.0pt;padding:3.75pt 7.5pt 3.75pt 7.5pt'>
    <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体;color:black'>快速开发、微服务、原型项目</span></p>
    </td>
   </tr>
  </table>
  <div class=MsoNormal align=left style='text-align:left'><span lang=EN-US
  style='font-size:12.0pt;font-family:宋体'>
  <hr size=1 width="100%" noshade style='color:black' align=left>
  </span></div>
  <p class=MsoNormal><b><span lang=EN-US style='font-size:12.0pt;font-family:
  宋体'>4. </span></b><b><span style='font-size:12.0pt;font-family:宋体'>代码示例对比</span></b></p>
  <p class=MsoNormal><b><span lang=EN-US style='font-size:12.0pt;font-family:
  宋体'>Spring MVC </span></b><b><span style='font-size:12.0pt;font-family:宋体'>项目配置</span></b></p>
  <ul style='margin-top:0cm' type=disc>
   <li class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:
       宋体'>// </span><span style='font-size:12.0pt;font-family:宋体'>手动配置<span
       lang=EN-US> DispatcherServlet</span></span></li>
   <li class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:
       宋体'>public class WebConfig implements WebMvcConfigurer {</span></li>
   <li class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:
       宋体'>&nbsp;&nbsp;&nbsp; @Bean</span></li>
   <li class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:
       宋体'>&nbsp;&nbsp;&nbsp; public ViewResolver viewResolver() {</span></li>
   <li class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:
       宋体'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
       InternalResourceViewResolver resolver = new
       InternalResourceViewResolver();</span></li>
   <li class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:
       宋体'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
       resolver.setPrefix(&quot;/WEB-INF/views/&quot;);</span></li>
   <li class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:
       宋体'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
       resolver.setSuffix(&quot;.jsp&quot;);</span></li>
   <li class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:
       宋体'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return resolver;</span></li>
   <li class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:
       宋体'>&nbsp;&nbsp;&nbsp; }</span></li>
   <li class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:
       宋体'>}<b>Spring Boot </b></span><b><span style='font-size:12.0pt;
       font-family:宋体'>项目配置</span></b></li>
  </ul>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>@SpringBootApplication</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>public
  class DemoApplication {</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;&nbsp;&nbsp;
  public static void main(String[] args) {</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  SpringApplication.run(DemoApplication.class, args);</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;&nbsp;&nbsp;
  }</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>}</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>//
  </span><span style='font-size:12.0pt;font-family:宋体'>自动配置视图解析器，只需添加依赖</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>//
  spring-boot-starter-web </span><span style='font-size:12.0pt;font-family:
  宋体'>和<span lang=EN-US> spring-boot-starter-thymeleaf</span></span></p>
  <div class=MsoNormal align=left style='text-align:left'><span lang=EN-US
  style='font-size:12.0pt;font-family:宋体'>
  <hr size=1 width="100%" noshade style='color:black' align=left>
  </span></div>
  <p class=MsoNormal><b><span lang=EN-US style='font-size:12.0pt;font-family:
  宋体'>5. </span></b><b><span style='font-size:12.0pt;font-family:宋体'>总结</span></b></p>
  <ul style='margin-top:0cm' type=disc>
   <li class=MsoNormal><b><span lang=EN-US style='font-size:12.0pt;font-family:
       宋体'>Spring</span></b><span lang=EN-US style='font-size:12.0pt;
       font-family:宋体'>&nbsp;</span><span style='font-size:12.0pt;font-family:
       宋体'>是基础框架，灵活但配置复杂，适合大型定制化项目。</span></li>
   <li class=MsoNormal><b><span lang=EN-US style='font-size:12.0pt;font-family:
       宋体'>Spring Boot</span></b><span lang=EN-US style='font-size:12.0pt;
       font-family:宋体'>&nbsp;</span><span style='font-size:12.0pt;font-family:
       宋体'>是 <span lang=EN-US>Spring </span>的扩展，通过约定简化开发，适合快速构建现代应用。</span></li>
   <li class=MsoNormal><b><span style='font-size:12.0pt;font-family:宋体'>关系</span></b><span
       style='font-size:12.0pt;font-family:宋体'>：<span lang=EN-US>Spring Boot </span>基于<span
       lang=EN-US> Spring </span>构建，不是替代关系，而是互补工具。</span></li>
  </ul>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>选择依据：</span></p>
  <ul style='margin-top:0cm' type=disc>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>需要快速启动项目<span
       lang=EN-US> → Spring Boot</span>。</span></li>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>需要深度控制底层细节<span
       lang=EN-US> → Spring</span>。</span></li>
  </ul>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><b><span lang=EN-US style='font-size:12.0pt;font-family:
  宋体'>0-1</span></b><b><span style='font-size:12.0pt;font-family:宋体'>背包问题是一个典型的优化问题，可以用动态规划来解决。问题描述如下：</span></b></p>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>定义：给定<span
  lang=EN-US>n</span>个物品和一个承重为<span lang=EN-US>W</span>的背包，每个物品<span
  lang=EN-US>i</span>有一个重量<span lang=EN-US>w[i]</span>和一个价值<span lang=EN-US>v[i]</span>。目标是选择一些物品放入背包，使得这些物品的总重量不超过背包的承重，同时这些物品的总价值尽可能大。</span></p>
  <ul style='margin-top:0cm' type=disc>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>每个物品只能选择<span
       lang=EN-US>“</span>放入背包<span lang=EN-US>”</span>或<span lang=EN-US>“</span>不放入背包<span
       lang=EN-US>”</span>，不能只放入部分。</span></li>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>目标是最大化背包中物品的总价值。</span></li>
  </ul>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>动态规划解决方案：</span></p>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>动态规划解决<span
  lang=EN-US>0-1</span>背包问题的基本思想是构建一个表，其中每个单元格表示在前<span lang=EN-US>i</span>个物品中选择一些物品放入一个承重为<span
  lang=EN-US>j</span>的背包可以获得的最大价值。</span></p>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>步骤：</span></p>
  <ol style='margin-top:0cm' start=1 type=1>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>初始化一个二维数组<span
       lang=EN-US>dp[n+1][W+1]</span>，其中<span lang=EN-US>dp[i][w]</span>表示在前<span
       lang=EN-US>i</span>个物品中选择一些物品放入承重为<span lang=EN-US>w</span>的背包可以获得的最大价值。</span></li>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>设置边界条件：<span
       lang=EN-US>dp[0][…] = 0</span>，因为没有物品时，最大价值为<span lang=EN-US>0</span>。</span></li>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>填充动态规划表：</span></li>
   <ul style='margin-top:0cm' type=disc>
    <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>如果物品<span
        lang=EN-US>i</span>的重量<span lang=EN-US>w[i]</span>大于当前背包承重<span
        lang=EN-US>w</span>，则不能选择该物品，因此<span lang=EN-US>dp[i][w] = dp[i-1][w]</span>。</span></li>
    <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>如果物品<span
        lang=EN-US>i</span>可以放入背包，则需要决定是否放入：</span></li>
    <ul style='margin-top:0cm' type=circle>
     <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>如果不放入，则<span
         lang=EN-US>dp[i][w] = dp[i-1][w]</span>。</span></li>
     <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>如果放入，则<span
         lang=EN-US>dp[i][w] = dp[i-1][w-w[i]] + v[i]</span>，其中<span
         lang=EN-US>dp[i-1][w-w[i]]</span>是考虑物品<span lang=EN-US>i</span>放入背包后剩余重量的最大价值。</span></li>
    </ul>
    <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>取两种情况的最大值作为<span
        lang=EN-US>dp[i][w]</span>的值。</span></li>
   </ul>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>最终答案是<span
       lang=EN-US>dp[n][W]</span>，即考虑所有物品和最大承重时的最大价值。</span></li>
  </ol>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>0-1</span><span
  style='font-size:12.0pt;font-family:宋体'>背包问题是一个<span lang=EN-US>NP</span>完全问题，没有已知的多项式时间算法可以解决所有规模的<span
  lang=EN-US>0-1</span>背包问题。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><b><span style='font-size:12.0pt;font-family:宋体'>贪心选择背包问题</span></b></p>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>贪心选择背包问题与<span
  lang=EN-US>0-1</span>背包问题类似，但是解决策略不同。在贪心选择背包问题中，物品可以分割，即可以选择物品的一部分。</span></p>
  <p class=MsoNormal><b><span style='font-size:12.0pt;font-family:宋体'>特点</span></b><span
  style='font-size:12.0pt;font-family:宋体'>：</span></p>
  <ul style='margin-top:0cm' type=disc>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>物品可以分割，因此可以取物品的一部分。</span></li>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>目标仍然是最大化背包中物品的总价值。</span></li>
  </ul>
  <p class=MsoNormal><b><span style='font-size:12.0pt;font-family:宋体'>贪心策略</span></b><span
  style='font-size:12.0pt;font-family:宋体'>：<span lang=EN-US>&nbsp;</span>贪心选择背包问题通常采用贪心策略解决，即每次选择性价比最高的物品放入背包，直到背包放不下为止。性价比可以定义为价值与重量的比值。</span></p>
  <ol style='margin-top:0cm' start=1 type=1>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>计算所有物品的性价比（<span
       lang=EN-US>v[i]/w[i]</span>）。</span></li>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>按性价比从高到低对物品进行排序。</span></li>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>从排序后的物品列表中，依次选择物品放入背包，直到背包放不下为止。</span></li>
  </ol>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>贪心算法并不总是能得到最优解，但在某些特定情况下，贪心策略可以得到最优解。</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>NP</span><span
  style='font-size:12.0pt;font-family:宋体'>问题</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>NP</span><span
  style='font-size:12.0pt;font-family:宋体'>问题是一类决策问题的集合，其特点是可以在多项式时间内验证一个解是否正确，但是目前没有已知的多项式时间算法能够解决所有这类问题。</span></p>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>特点：</span></p>
  <ul style='margin-top:0cm' type=disc>
   <li class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:
       宋体'>NP</span><span style='font-size:12.0pt;font-family:宋体'>问题中的<span
       lang=EN-US>“NP”</span>代表<span lang=EN-US>“</span>非确定性多项式时间<span
       lang=EN-US>”</span>（<span lang=EN-US>Nondeterministic Polynomial time</span>）。</span></li>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>解决<span
       lang=EN-US>NP</span>问题可能需要指数级的时间复杂度。</span></li>
   <li class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:
       宋体'>NP</span><span style='font-size:12.0pt;font-family:宋体'>问题包括了许多著名的难题，如旅行商问题（<span
       lang=EN-US>TSP</span>）、子集和问题、汉密尔顿回路问题等。</span></li>
  </ul>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>分类：</span></p>
  <ul style='margin-top:0cm' type=disc>
   <li class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:
       宋体'>NP</span><span style='font-size:12.0pt;font-family:宋体'>完全问题：如果一个问题是<span
       lang=EN-US>NP</span>问题，并且所有的<span lang=EN-US>NP</span>问题都可以在多项式时间内归约到它，那么这个问题就是<span
       lang=EN-US>NP</span>完全问题。</span></li>
   <li class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:
       宋体'>NP</span><span style='font-size:12.0pt;font-family:宋体'>困难问题：至少和<span
       lang=EN-US>NP</span>完全问题一样难的问题，但可能不属于<span lang=EN-US>NP</span>问题。</span></li>
  </ul>
  <p class=MsoNormal><b><span lang=EN-US style='font-size:12.0pt;font-family:
  宋体'>&nbsp;</span></b></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><b><span lang=EN-US style='font-size:12.0pt;font-family:
  宋体'>&nbsp;</span></b></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><b><span style='font-size:12.0pt;font-family:宋体'>旅行商问题（<span
  lang=EN-US>TSP</span>）</span></b></p>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>旅行商问题（<span
  lang=EN-US>Traveling Salesman Problem, TSP</span>）是一个经典的组合优化问题。问题描述如下：</span></p>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>定义：给定一组城市和每两个城市之间的距离，要求找到一个最短的闭合回路（路径），使得旅行商从某个城市出发，访问每个城市恰好一次，并返回出发城市。</span></p>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>特点：</span></p>
  <ul style='margin-top:0cm' type=disc>
   <li class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:
       宋体'>TSP</span><span style='font-size:12.0pt;font-family:宋体'>是一个组合问题，因为它涉及到从所有可能的路径中选择一个最优路径。</span></li>
   <li class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:
       宋体'>TSP</span><span style='font-size:12.0pt;font-family:宋体'>的解空间随着城市数量的增加而呈指数增长，这使得找到最优解非常困难。</span></li>
   <li class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:
       宋体'>TSP</span><span style='font-size:12.0pt;font-family:宋体'>是一个<span
       lang=EN-US>NP</span>难问题，并且是<span lang=EN-US>NP</span>完全问题，这意味着没有已知的多项式时间算法可以解决所有规模的<span
       lang=EN-US>TSP</span>问题。</span></li>
  </ul>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>算法：</span></p>
  <ul style='margin-top:0cm' type=disc>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>暴力法：尝试所有可能的路径组合，时间复杂度为<span
       lang=EN-US>O(n!)</span>，只适用于城市数量很少的情况。</span></li>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>动态规划：基于动态规划的解决方案可以解决较小的实例，但对于大规模问题仍然不可行。</span></li>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>分支限界法：通过剪枝减少搜索空间，可以找到最优解，但计算时间仍然很长。</span></li>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>遗传算法、模拟退火、蚁群算法等启发式算法：用于寻找近似最优解，适用于大规模问题。</span></li>
  </ul>
  <p class=MsoNormal><b><span lang=EN-US style='font-size:12.0pt;font-family:
  宋体'>&nbsp;</span></b></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>冒泡排序（<span
  lang=EN-US>Bubble Sort</span>）</span></p>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>冒泡排序是一种简单的排序算法，它重复地遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</span></p>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>算法步骤：</span></p>
  <ol style='margin-top:0cm' start=1 type=1>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>比较相邻的元素。如果第一个比第二个大（升序排序），就交换它们两个。</span></li>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</span></li>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>针对所有的元素重复以上的步骤，除了最后一个。</span></li>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>重复步骤<span
       lang=EN-US>1~3</span>，直到排序完成。</span></li>
  </ol>
  <p class=MsoNormal><b><span lang=EN-US style='font-size:12.0pt;font-family:
  宋体'>&nbsp;</span></b></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><b><span style='font-size:12.0pt;font-family:宋体'>选择排序（<span
  lang=EN-US>Selection Sort</span>）</span></b></p>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>选择排序是一种简单直观的排序算法。它的工作原理是：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</span></p>
  <p class=MsoNormal><b><span style='font-size:12.0pt;font-family:宋体'>算法步骤</span></b><span
  style='font-size:12.0pt;font-family:宋体'>：</span></p>
  <ol style='margin-top:0cm' start=1 type=1>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</span></li>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</span></li>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>重复第二步，直到所有元素均排序完毕。</span></li>
  </ol>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><b><span style='font-size:12.0pt;font-family:宋体'>插入排序（<span
  lang=EN-US>Insertion Sort</span>）</span></b></p>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>插入排序是一种简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</span></p>
  <p class=MsoNormal><b><span style='font-size:12.0pt;font-family:宋体'>算法步骤</span></b><span
  style='font-size:12.0pt;font-family:宋体'>：</span></p>
  <ol style='margin-top:0cm' start=1 type=1>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>从第一个元素开始，该元素可以认为已经被排序。</span></li>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>取出下一个元素，在已经排序的元素序列中从后向前扫描。</span></li>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>如果该元素（已排序）大于新元素，将该元素移到下一位置。</span></li>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>重复步骤<span
       lang=EN-US>3</span>，直到找到已排序的元素小于或者等于新元素的位置。</span></li>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>将新元素插入到该位置后。</span></li>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>重复步骤<span
       lang=EN-US>2~5</span>。</span></li>
  </ol>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><b><span style='font-size:12.0pt;font-family:宋体'>快速排序（<span
  lang=EN-US>Quick Sort</span>）</span></b></p>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>快速排序是由东尼<span
  lang=EN-US>・</span>霍尔所发展的一种排序算法。在平均状况下，排序<span lang=EN-US> n </span>个项目要<span
  lang=EN-US>Ο(n log n)</span>次比较。在最坏状况下则需要<span lang=EN-US>Ο(n^2)</span>次比较，但这种状况并不常见。事实上，快速排序通常明显比其他<span
  lang=EN-US>Ο(n log n)</span>算法更快，因为它的内部循环（<span lang=EN-US>inner loop</span>）可以在大多数架构上更有效地运行。</span></p>
  <p class=MsoNormal><b><span style='font-size:12.0pt;font-family:宋体'>算法步骤</span></b><span
  style='font-size:12.0pt;font-family:宋体'>：</span></p>
  <ol style='margin-top:0cm' start=1 type=1>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>从数列中挑出一个元素，称为<span
       lang=EN-US> “</span>基准<span lang=EN-US>”</span>（<span lang=EN-US>pivot</span>）。</span></li>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（<span
       lang=EN-US>partition</span>）操作。</span></li>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>递归地（<span
       lang=EN-US>recursive</span>）把小于基准值元素的子数列和大于基准值元素的子数列排序。</span></li>
  </ol>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=697 valign=top style='width:522.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>归并排序（<span
  lang=EN-US>Merge Sort</span>）</span></p>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（<span
  lang=EN-US>Divide and Conquer</span>）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。</span></p>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>算法步骤：</span></p>
  <ol style='margin-top:0cm' start=1 type=1>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列。</span></li>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>设定两个指针，最初位置分别为两个已经排序序列的起始位置。</span></li>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置。</span></li>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>重复步骤<span
       lang=EN-US>3</span>直到某一指针达到序列尾。</span></li>
   <li class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>将另一序列剩下的所有元素直接复制到合并序列尾。</span></li>
  </ol>
  <p class=MsoNormal><b><span lang=EN-US style='font-size:12.0pt;font-family:
  宋体'>&nbsp;</span></b></p>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal><span lang=EN-US style='font-family:"Times New Roman",serif'>&nbsp;</span></p>

<div align=center>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='border-collapse:collapse;border:none'>
 <thead>
  <tr>
   <td style='border-top:solid windowtext 1.0pt;border-left:solid windowtext 1.0pt;
   border-bottom:none;border-right:none;padding:7.9pt 12.0pt 7.9pt 12.0pt'>
   <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>维度</span></p>
   </td>
   <td style='border:none;border-top:solid windowtext 1.0pt;padding:7.9pt 12.0pt 7.9pt 12.0pt'>
   <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:
   "Times New Roman",serif'>&#8203;</span><span style='font-size:12.0pt;font-family:
   宋体'>瀑布模型</span></p>
   </td>
   <td style='border:none;border-top:solid windowtext 1.0pt;padding:7.9pt 12.0pt 7.9pt 12.0pt'>
   <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:
   "Times New Roman",serif'>&#8203;</span><span style='font-size:12.0pt;font-family:
   宋体'>敏捷开发</span></p>
   </td>
   <td style='border:none;border-top:solid windowtext 1.0pt;padding:7.9pt 12.0pt 7.9pt 12.0pt'>
   <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:
   "Times New Roman",serif'>&#8203;</span><span style='font-size:12.0pt;font-family:
   宋体'>迭代开发</span></p>
   </td>
   <td style='border-top:solid windowtext 1.0pt;border-left:none;border-bottom:
   none;border-right:solid windowtext 1.0pt;padding:7.9pt 12.0pt 7.9pt 12.0pt'>
   <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:
   "Times New Roman",serif'>&#8203;</span><span lang=EN-US style='font-size:12.0pt;
   font-family:宋体'>DevOps</span></p>
   </td>
  </tr>
 </thead>
 <tr>
  <td style='border:none;border-left:solid windowtext 1.0pt;padding:7.9pt 12.0pt 7.9pt 12.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:"Times New Roman",serif'>&#8203;</span><span
  style='font-size:12.0pt;font-family:宋体'>核心目标</span></p>
  </td>
  <td style='border:none;padding:7.9pt 12.0pt 7.9pt 12.0pt'>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>严格流程控制</span></p>
  </td>
  <td style='border:none;padding:7.9pt 12.0pt 7.9pt 12.0pt'>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>快速响应变化</span></p>
  </td>
  <td style='border:none;padding:7.9pt 12.0pt 7.9pt 12.0pt'>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>逐步交付功能</span></p>
  </td>
  <td style='border:none;border-right:solid windowtext 1.0pt;padding:7.9pt 12.0pt 7.9pt 12.0pt'>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>持续交付与自动化</span></p>
  </td>
 </tr>
 <tr>
  <td style='border:none;border-left:solid windowtext 1.0pt;padding:7.9pt 12.0pt 7.9pt 12.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:"Times New Roman",serif'>&#8203;</span><span
  style='font-size:12.0pt;font-family:宋体'>需求适应性</span></p>
  </td>
  <td style='border:none;padding:7.9pt 12.0pt 7.9pt 12.0pt'>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>需求固定不变</span></p>
  </td>
  <td style='border:none;padding:7.9pt 12.0pt 7.9pt 12.0pt'>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>需求频繁变更</span></p>
  </td>
  <td style='border:none;padding:7.9pt 12.0pt 7.9pt 12.0pt'>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>需求部分明确</span></p>
  </td>
  <td style='border:none;border-right:solid windowtext 1.0pt;padding:7.9pt 12.0pt 7.9pt 12.0pt'>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>需求动态调整</span></p>
  </td>
 </tr>
 <tr>
  <td style='border:none;border-left:solid windowtext 1.0pt;padding:7.9pt 12.0pt 7.9pt 12.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:"Times New Roman",serif'>&#8203;</span><span
  style='font-size:12.0pt;font-family:宋体'>交付节奏</span></p>
  </td>
  <td style='border:none;padding:7.9pt 12.0pt 7.9pt 12.0pt'>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>一次性交付</span></p>
  </td>
  <td style='border:none;padding:7.9pt 12.0pt 7.9pt 12.0pt'>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>短期迭代（<span
  lang=EN-US>2-4</span>周）</span></p>
  </td>
  <td style='border:none;padding:7.9pt 12.0pt 7.9pt 12.0pt'>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>多版本迭代</span></p>
  </td>
  <td style='border:none;border-right:solid windowtext 1.0pt;padding:7.9pt 12.0pt 7.9pt 12.0pt'>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>持续交付（按需发布）</span></p>
  </td>
 </tr>
 <tr>
  <td style='border:none;border-left:solid windowtext 1.0pt;padding:7.9pt 12.0pt 7.9pt 12.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:"Times New Roman",serif'>&#8203;</span><span
  style='font-size:12.0pt;font-family:宋体'>文档要求</span></p>
  </td>
  <td style='border:none;padding:7.9pt 12.0pt 7.9pt 12.0pt'>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>详尽文档</span></p>
  </td>
  <td style='border:none;padding:7.9pt 12.0pt 7.9pt 12.0pt'>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>轻量文档</span></p>
  </td>
  <td style='border:none;padding:7.9pt 12.0pt 7.9pt 12.0pt'>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>中等文档</span></p>
  </td>
  <td style='border:none;border-right:solid windowtext 1.0pt;padding:7.9pt 12.0pt 7.9pt 12.0pt'>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>自动化脚本为主</span></p>
  </td>
 </tr>
 <tr>
  <td style='border:none;border-left:solid windowtext 1.0pt;padding:7.9pt 12.0pt 7.9pt 12.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:"Times New Roman",serif'>&#8203;</span><span
  style='font-size:12.0pt;font-family:宋体'>团队协作</span></p>
  </td>
  <td style='border:none;padding:7.9pt 12.0pt 7.9pt 12.0pt'>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>严格分工</span></p>
  </td>
  <td style='border:none;padding:7.9pt 12.0pt 7.9pt 12.0pt'>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>高度自组织</span></p>
  </td>
  <td style='border:none;padding:7.9pt 12.0pt 7.9pt 12.0pt'>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>阶段性协作</span></p>
  </td>
  <td style='border:none;border-right:solid windowtext 1.0pt;padding:7.9pt 12.0pt 7.9pt 12.0pt'>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>开发与运维深度整合</span></p>
  </td>
 </tr>
 <tr>
  <td style='border:none;border-left:solid windowtext 1.0pt;padding:7.9pt 12.0pt 7.9pt 12.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:"Times New Roman",serif'>&#8203;</span><span
  style='font-size:12.0pt;font-family:宋体'>典型工具</span></p>
  </td>
  <td style='border:none;padding:7.9pt 12.0pt 7.9pt 12.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>Microsoft
  Project</span></p>
  </td>
  <td style='border:none;padding:7.9pt 12.0pt 7.9pt 12.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>JIRA</span><span
  style='font-size:12.0pt;font-family:宋体'>、<span lang=EN-US>Trello</span></span></p>
  </td>
  <td style='border:none;padding:7.9pt 12.0pt 7.9pt 12.0pt'>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>无特定工具</span></p>
  </td>
  <td style='border:none;border-right:solid windowtext 1.0pt;padding:7.9pt 12.0pt 7.9pt 12.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:宋体'>Jenkins</span><span
  style='font-size:12.0pt;font-family:宋体'>、<span lang=EN-US>GitLab CI/CD</span></span></p>
  </td>
 </tr>
 <tr>
  <td style='border-top:none;border-left:solid windowtext 1.0pt;border-bottom:
  solid windowtext 1.0pt;border-right:none;padding:7.9pt 12.0pt 7.9pt 12.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:12.0pt;font-family:"Times New Roman",serif'>&#8203;</span><span
  style='font-size:12.0pt;font-family:宋体'>适用项目</span></p>
  </td>
  <td style='border:none;border-bottom:solid windowtext 1.0pt;padding:7.9pt 12.0pt 7.9pt 12.0pt'>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>传统行业大型系统</span></p>
  </td>
  <td style='border:none;border-bottom:solid windowtext 1.0pt;padding:7.9pt 12.0pt 7.9pt 12.0pt'>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>互联网产品</span></p>
  </td>
  <td style='border:none;border-bottom:solid windowtext 1.0pt;padding:7.9pt 12.0pt 7.9pt 12.0pt'>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>中大型企业软件</span></p>
  </td>
  <td style='border-top:none;border-left:none;border-bottom:solid windowtext 1.0pt;
  border-right:solid windowtext 1.0pt;padding:7.9pt 12.0pt 7.9pt 12.0pt'>
  <p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>云原生应用</span></p>
  </td>
 </tr>
</table>

</div>

<ul style='margin-top:0cm' type=disc>
 <li class=MsoNormal style='text-align:center'><span lang=EN-US
     style='font-family:"Times New Roman",serif'>&#8203;</span><b>敏捷开发</b>是<span
     lang=EN-US style='font-family:"Times New Roman",serif'>“</span>小步快跑，随时转向<span
     lang=EN-US style='font-family:"Times New Roman",serif'>”</span>，适合探索性项目。</li>
 <li class=MsoNormal style='text-align:center'><span lang=EN-US
     style='font-family:"Times New Roman",serif'>&#8203;</span><b>迭代开发</b>是<span
     lang=EN-US style='font-family:"Times New Roman",serif'>“</span>分阶段行军，稳扎稳打<span
     lang=EN-US style='font-family:"Times New Roman",serif'>”</span>，适合目标明确的工程。</li>
</ul>

</div>

</body>

</html>
